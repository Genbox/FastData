using System.Text;
using Genbox.FastData.Enums;
using Genbox.FastData.Internal.Abstracts;
using Genbox.FastData.Internal.Analysis;
using Genbox.FastData.Internal.Analysis.Genetic;
using Genbox.FastData.Internal.Analysis.Properties;
using Genbox.FastData.Internal.Enums;
using Genbox.FastData.Internal.Generators;
using Genbox.FastData.Internal.Optimization;

namespace Genbox.FastData.Internal;

internal static class Generator
{
    public static void Generate(StringBuilder sb, FastDataSpec spec)
    {
        AppendHeader(sb, spec);
        AppendDataStructure(sb, spec);
        AppendFooter(sb, spec);
    }

    private static void AppendHeader(StringBuilder sb, FastDataSpec spec)
    {
        string? ns = spec.Namespace != null ? $"namespace {spec.Namespace};\n" : null;
        string cn = spec.Name;
        string visibility = spec.ClassVisibility.ToString().ToLowerInvariant();

        string type = spec.ClassType switch
        {
            ClassType.Static => " static class",
            ClassType.Instance => " class",
            ClassType.Struct => " struct",
            _ => throw new InvalidOperationException("Invalid type: " + spec.ClassType)
        };

        // = spec.Mode.HasFlag(StorageFlags.Struct) ? "struct" : "class";
        string? attr = spec.ClassType == ClassType.Struct ? "[StructLayout(LayoutKind.Auto)]" : null;
        string? iface = spec.ClassType != ClassType.Static ? " : IFastSet" : null;
        string? partial = spec.ClassType != ClassType.Static ? " partial" : null;

        // AssemblyName name = typeof(FastDataGenerator).Assembly.GetName();
        sb.AppendLine("// <auto-generated />");

#if RELEASE
        System.Reflection.AssemblyName name = typeof(FastDataGenerator).Assembly.GetName();
        sb.Append("// Generated by ").Append(name.Name).Append(' ').AppendLine(name.Version.ToString());
        sb.Append("// Generated on: ").AppendFormat(System.Globalization.DateTimeFormatInfo.InvariantInfo, "{0:yyyy-MM-dd HH:mm:ss}", DateTime.UtcNow).AppendLine(" UTC");
#endif

        sb.Append($$"""
                    #nullable enable
                    using Genbox.FastData;
                    using Genbox.FastData.Abstracts;
                    using Genbox.FastData.Helpers;
                    using System.Runtime.InteropServices;
                    using System.Runtime.CompilerServices;
                    using System.Text;
                    using System;

                    {{ns}}
                    {{attr}}{{visibility}}{{partial}}{{type}} {{cn}} {{iface}}
                    {

                    """);
    }

    private static void AppendDataStructure(StringBuilder sb, FastDataSpec spec)
    {
        //No matter the StorageMode, if there is only a single item, we will use the same data structure
        if (spec.Data.Length == 1)
        {
            Generate(DataStructure.SingleValue, sb, spec);
            return;
        }

        foreach (ICode candidate in GetDataStructureCandidates(spec))
        {
            if (candidate.TryCreate())
            {
                sb.Append(candidate.Generate());
                break;
            }
        }
    }

    private static IEnumerable<ICode> GetDataStructureCandidates(FastDataSpec spec)
    {
        GeneratorContext context = new GeneratorContext(spec);

        switch (spec.StorageMode)
        {
            case StorageMode.Auto:

                // For small amounts of data, logic is the fastest, so we try that first
                yield return new SwitchCode(spec, context);

                // We try (unique) key lengths
                yield return new UniqueKeyLengthCode(spec, context);
                yield return new KeyLengthCode(spec, context);

                if (spec.StorageOptions.HasFlag(StorageOption.OptimizeForMemory) && spec.StorageOptions.HasFlag(StorageOption.OptimizeForSpeed))
                    yield return new MinimalPerfectHashCode(spec, context);

                if (spec.StorageOptions.HasFlag(StorageOption.OptimizeForMemory))
                    yield return new BinarySearchCode(spec, context);
                else
                    yield return new HashSetCode(spec, context);

                break;
            case StorageMode.Linear:
                yield return new ArrayCode(spec, context);
                break;
            case StorageMode.Logic:
                yield return new SwitchCode(spec, context);
                break;
            case StorageMode.Tree:
                yield return new BinarySearchCode(spec, context);
                break;
            case StorageMode.Indexed:
                yield return new HashSetCode(spec, context);
                break;

            default:
                throw new InvalidOperationException($"Unsupported StorageMode {spec.StorageMode}");
        }
    }

    private static void AppendFooter(StringBuilder sb, FastDataSpec spec)
    {
        sb.Append($"""


                       public const int ItemCount = {spec.Data.Length};
                   """);

        if (spec.ClassType == ClassType.Instance)
        {
            sb.Append($"""

                           public int Length => {spec.Data.Length};
                       """);
        }

        sb.AppendLine();
        sb.Append('}');
    }

    /// <summary>This method is used by tests</summary>
    internal static void Generate(DataStructure ds, StringBuilder sb, FastDataSpec spec)
    {
        GeneratorContext context = new GeneratorContext(spec);

        ICode instance = ds switch
        {
            DataStructure.Array => new ArrayCode(spec, context),
            DataStructure.BinarySearch => new BinarySearchCode(spec, context),
            DataStructure.EytzingerSearch => new EytzingerSearchCode(spec, context),
            DataStructure.Switch => new SwitchCode(spec, context),
            DataStructure.SwitchHashCode => new SwitchHashCode(spec, context),
            DataStructure.MinimalPerfectHash => new MinimalPerfectHashCode(spec, context),
            DataStructure.HashSet => new HashSetCode(spec, context),
            DataStructure.UniqueKeyLength => new UniqueKeyLengthCode(spec, context),
            DataStructure.UniqueKeyLengthSwitch => new UniqueKeyLengthSwitchCode(spec, context),
            DataStructure.KeyLength => new KeyLengthCode(spec, context),
            DataStructure.SingleValue => new SingleValueCode(spec, context),
            DataStructure.Conditional => new ConditionalCode(spec, context),
            _ => throw new ArgumentOutOfRangeException(nameof(ds), ds, null)
        };

        if (instance.TryCreate())
            sb.Append(instance.Generate());
    }
}

internal class GeneratorContext(FastDataSpec spec)
{
    private IHashSpec? _hashSpec;
    private IEarlyExit[]? _earlyExits;
    private DataProperties? _dataProperties;

    internal DataProperties GetDataProperties()
    {
        if (_dataProperties == null)
        {
            _dataProperties = new DataProperties();

            switch (spec.KnownDataType)
            {
                case KnownDataType.SByte:
                    _dataProperties.IntProps = DataAnalyzer.GetSByteProperties(spec.Data);
                    break;
                case KnownDataType.Byte:
                    _dataProperties.UIntProps = DataAnalyzer.GetByteProperties(spec.Data);
                    break;
                case KnownDataType.Int16:
                    _dataProperties.IntProps = DataAnalyzer.GetInt16Properties(spec.Data);
                    break;
                case KnownDataType.UInt16:
                    _dataProperties.UIntProps = DataAnalyzer.GetUInt16Properties(spec.Data);
                    break;
                case KnownDataType.Int32:
                    _dataProperties.IntProps = DataAnalyzer.GetInt32Properties(spec.Data);
                    break;
                case KnownDataType.UInt32:
                    _dataProperties.UIntProps = DataAnalyzer.GetUInt32Properties(spec.Data);
                    break;
                case KnownDataType.Int64:
                    _dataProperties.IntProps = DataAnalyzer.GetInt64Properties(spec.Data);
                    break;
                case KnownDataType.UInt64:
                    _dataProperties.UIntProps = DataAnalyzer.GetUInt64Properties(spec.Data);
                    break;
                case KnownDataType.String:
                    _dataProperties.StringProps = DataAnalyzer.GetStringProperties(spec.Data);
                    break;
                case KnownDataType.Boolean:
                    break;
                case KnownDataType.Char:
                    _dataProperties.CharProps = DataAnalyzer.GetCharProperties(spec.Data);
                    break;
                case KnownDataType.Single:
                    _dataProperties.FloatProps = DataAnalyzer.GetSingleProperties(spec.Data);
                    break;
                case KnownDataType.Double:
                    _dataProperties.FloatProps = DataAnalyzer.GetDoubleProperties(spec.Data);
                    break;
                case KnownDataType.Unknown:
                    //Do nothing
                    break;
                default:
                    throw new InvalidOperationException("Unknown data type: " + spec.KnownDataType);
            }
        }

        return _dataProperties;
    }

    internal IEarlyExit[] GetEarlyExits()
    {
        if (_earlyExits == null)
        {
            DataProperties props = GetDataProperties();

            if (props.StringProps.HasValue)
                _earlyExits = Optimizer.GetEarlyExits(props.StringProps.Value).ToArray();
            else if (props.IntProps.HasValue)
                _earlyExits = Optimizer.GetEarlyExits(props.IntProps.Value).ToArray();
            else if (props.UIntProps.HasValue)
                _earlyExits = Optimizer.GetEarlyExits(props.UIntProps.Value).ToArray();
            else if (props.CharProps.HasValue)
                _earlyExits = Optimizer.GetEarlyExits(props.CharProps.Value).ToArray();
            else if (props.FloatProps.HasValue)
                _earlyExits = Optimizer.GetEarlyExits(props.FloatProps.Value).ToArray();
            else
                _earlyExits = [];
        }

        return _earlyExits;
    }

    internal IHashSpec GetHashSpec()
    {
        if (_hashSpec == null)
        {
            //TODO: Generate
            _hashSpec = null;
        }

        return _hashSpec;
    }
}