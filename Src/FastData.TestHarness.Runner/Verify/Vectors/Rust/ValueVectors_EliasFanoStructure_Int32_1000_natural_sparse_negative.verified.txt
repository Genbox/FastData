//! This file is auto-generated. Do not edit manually.
//! Structure: EliasFano
#![allow(unused_parens)]
#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(unused_unsafe)]
use std::ptr;

pub struct EliasFanoStructure_Int32_1000_natural_sparse_negative;

impl EliasFanoStructure_Int32_1000_natural_sparse_negative {
    const LOWER_BIT_COUNT: i32 = 4;
    const MIN_VALUE: i64 = -198273;
    const MAX_VALUE: i64 = -171245;
    const MAX_VALUE_NORMALIZED: i64 = 27028;
    const UPPER_BITS: [u64; 43] = [
        11535226534270511963, 12106474960098863798, 6125096337533130166, 234237026632379757, u64::MIN, 13066832212270252032, 13066470108627522901, 7686357402408463021, 6150468668486583659, 111804763, 
        u64::MIN, 6149669047885452651, 12310028189108448091, 12298627261436439222, 391144710509778358, u64::MIN, 15756642456625479680, 13066832213171322906, 13066470108638652421, 7686357402409855489, 
        190142080, u64::MIN, 7686355942026095277, 6150468485180642667, 12310261171220032347, 769458801468943030, u64::MIN, 816659418262274048, 192202145890216624, 24407692306372020, 
        11535246235332685165, 190147434, u64::MIN, 13066470107876087125, 7686357402220604077, 6150468668431357291, 781046153792760667, u64::MIN, 6053589320894251008, 12285920297157831515, 
        12294852088262470326, 6154176221064549814, 1
    ];

    const LOWER_BITS: [u64; 63] = [
        12636060196807291264, 14147968314379338038, 4109552257374051405, 125581634409093038, 15331735649828538384, 6315930693306793511, 9266307683119842628, 13702021880517437105, 5606100993449171081, 2788159246640263004, 
        1153263106379336927, 12636059610418919688, 4924596277524562230, 4109552294006609093, 9925414423567292334, 15331735647554732184, 16079734685446028839, 9266307683246165452, 3940469688191887025, 5606100993441271809, 
        12554074301104828252, 1153263106378777687, 2870135759861332232, 4924596277524597182, 12790390659100431557, 9925414423567294246, 6651197483495030936, 16079734685446028975, 580965686312717772, 3940469688191887033, 
        14214582729680883713, 12554074301104828252, 1768153407002330199, 2870135759861332232, 4962727858194123198, 12790390659100431557, 9923311639934590758, 6651197483495030936, 16079602226363971247, 580965686312717772, 
        3940461405204360761, 14214582729680883713, 12554074887510960084, 10991525443857106007, 2870135796493889920, 14762560647352322494, 12790390656827612237, 87450053757427494, 6651197483621353488, 6318050034038421167, 
        580965686320612676, 13702154335018266169, 14214582729680394377, 2788151036953372628, 10991525443857140959, 12636060196807291264, 14762560647352320310, 4109552257374051405, 87450053757427630, 15331735649828538384, 
        6318050034038421159, 9266307683119842628, 1146596921
    ];

    const LOWER_MASK: u64 = 15;

    const SAMPLE_RATE_SHIFT: i32 = 7;
    const SAMPLE_POSITIONS: [i32; 14] = [
        0, 255, 417, 638, 830, 1021, 1245, 1404, 1658, 1813, 
        2042, 2228, 2425, 2641
    ];

    #[must_use]
    pub fn contains(key: i32) -> bool {
        if key < -198273 || key > -171245 {
            return false;
        }


        let value = (key as i64) - Self::MIN_VALUE;
        if (value as u64) > (Self::MAX_VALUE_NORMALIZED as u64) {
            return false;
        }
        let high = value >> (Self::LOWER_BIT_COUNT as u32);

        let position = if high == 0 { 0 } else { Self::select_zero(high - 1) + 1 };
        if position < 0 {
            return false;
        }

        let mut rank = position - high;
        if (rank as u64) >= Self::ITEM_COUNT as u64 {
            return false;
        }

        let mut curr_word = (position >> 6) as usize;

        if curr_word >= Self::UPPER_BITS.len() {
            return false;
        }

        let mut window = Self::UPPER_BITS[curr_word] & (u64::MAX << ((position & 63) as u32));
        let target_low = (value as u64) & Self::LOWER_MASK;
        let mut lower_bits_offset = rank * (Self::LOWER_BIT_COUNT as i64);

        loop {
            while window == 0 {
                curr_word += 1;
                if curr_word >= Self::UPPER_BITS.len() {
                    return false;
                }

                window = Self::UPPER_BITS[curr_word];
            }

            let trailing = window.trailing_zeros() as i64;
            let one_position = ((curr_word as i64) << 6) + trailing;
            let current_high = one_position - rank;

            if current_high >= high {
                if current_high > high {
                    return false;
                }

                let word_index = (lower_bits_offset >> 6) as usize;
                let start_bit = (lower_bits_offset & 63) as u32;

                let current_low = if start_bit + (Self::LOWER_BIT_COUNT as u32) <= 64 {
                    (Self::LOWER_BITS[word_index] >> start_bit) & Self::LOWER_MASK
                } else {
                    let lower = Self::LOWER_BITS[word_index] >> start_bit;
                    let upper = Self::LOWER_BITS[word_index + 1] << (64 - start_bit);
                    (lower | upper) & Self::LOWER_MASK
                };

                if current_low == target_low {
                    return true;
                }

                if current_low > target_low {
                    return false;
                }
            }

            window &= window - 1;
            rank += 1;

            if (rank as u64) >= Self::ITEM_COUNT as u64 {
                return false;
            }

            lower_bits_offset += Self::LOWER_BIT_COUNT as i64;
        }
    }

    fn select_zero(rank: i64) -> i64 {
        if rank < 0 {
            return -1;
        }

        let sample_index = (rank >> (Self::SAMPLE_RATE_SHIFT as u32)) as usize;
        if sample_index >= Self::SAMPLE_POSITIONS.len() {
            return -1;
        }

        let mut zero_rank = (sample_index as i64) << (Self::SAMPLE_RATE_SHIFT as u32);
        let start_position = Self::SAMPLE_POSITIONS[sample_index] as i64;
        let mut word_index = (start_position >> 6) as usize;
        let mut start_bit = (start_position & 63) as u32;

        while word_index < Self::UPPER_BITS.len() {
            let valid_bits = if word_index == Self::UPPER_BITS.len() - 1 { 1 } else { 64 };
            let valid_mask = if valid_bits == 64 { u64::MAX } else { (1u64 << (valid_bits as u32)) - 1 };
            let mut zeros = !Self::UPPER_BITS[word_index] & valid_mask;

            if start_bit > 0 {
                zeros &= !((1u64 << start_bit) - 1);
                start_bit = 0;
            }

            let zero_count = zeros.count_ones() as i64;
            if zero_count == 0 {
                word_index += 1;
                continue;
            }

            if zero_rank + zero_count > rank {
                let rank_in_word = (rank - zero_rank) as i32;
                let bit_in_word = Self::select_bit_in_word(zeros, rank_in_word);
                return ((word_index as i64) << 6) + bit_in_word as i64;
            }

            zero_rank += zero_count;
            word_index += 1;
        }

        -1
    }

    #[inline(always)]
    fn select_bit_in_word(word: u64, rank: i32) -> i32 {
        if rank < 0 || rank >= 64 {
            return -1;
        }

        let mut remaining = rank;
        let mut value = word;

        while remaining > 0 {
            if value == 0 {
                return -1;
            }

            value &= value - 1;
            remaining -= 1;
        }

        if value == 0 {
            return -1;
        }

        value.trailing_zeros() as i32
    }

    pub const ITEM_COUNT: usize = 1000;
    pub const MIN_KEY: i32 = -198273;
    pub const MAX_KEY: i32 = -171245;
}