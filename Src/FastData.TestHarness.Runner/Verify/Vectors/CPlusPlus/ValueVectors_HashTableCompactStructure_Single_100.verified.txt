// This file is auto-generated. Do not edit manually.
// Structure: Auto (HashTableCompact)
#pragma once
#include <array>
#include <cstdint>
#include <limits>
#include <string_view>

class HashTableCompactStructure_Single_100 final {
    struct e {
        float key;
        uint64_t hash_code;
        
        e(const float key, const uint64_t hash_code)
           : key(key), hash_code(hash_code) {}
    };

    static constexpr std::array<uint8_t, 100> bucket_starts = {
        0, 5, 5, 5, 5, 8, 8, 8, 8, 11, 
        11, 11, 11, 15, 15, 15, 15, 20, 20, 20, 
        20, 24, 24, 24, 24, 29, 29, 29, 29, 33, 
        33, 33, 33, 37, 37, 37, 37, 42, 42, 42, 
        42, 47, 47, 47, 47, 51, 51, 51, 51, 54, 
        54, 54, 54, 58, 58, 58, 58, 61, 61, 61, 
        61, 63, 63, 63, 63, 67, 67, 67, 67, 72, 
        72, 72, 72, 75, 75, 75, 75, 79, 79, 79, 
        79, 83, 83, 83, 83, 87, 87, 87, 87, 92, 
        92, 92, 92, 96, 96, 96, 96, 100, 100, 100
     };

    static constexpr std::array<uint8_t, 100> bucket_counts = {
        5, 0, 0, 0, 3, 0, 0, 0, 3, 0, 
        0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 
        4, 0, 0, 0, 5, 0, 0, 0, 4, 0, 
        0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 
        5, 0, 0, 0, 4, 0, 0, 0, 3, 0, 
        0, 0, 4, 0, 0, 0, 3, 0, 0, 0, 
        2, 0, 0, 0, 4, 0, 0, 0, 5, 0, 
        0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 
        4, 0, 0, 0, 4, 0, 0, 0, 5, 0, 
        0, 0, 4, 0, 0, 0, 4, 0, 0, 0
     };

    inline static const std::array<e, 100> entries = {
        e(0.0f, 0), e(20.0f, 1101004800), e(33.0f, 1107558400), e(58.0f, 1114112000), e(77.0f, 1117388800), e(28.0f, 1105199104), e(49.0f, 1111752704), e(84.0f, 1118306304), e(40.0f, 1109393408), e(66.0f, 1115947008), 
        e(91.0f, 1119223808), e(19.0f, 1100480512), e(56.0f, 1113587712), e(73.0f, 1116864512), e(98.0f, 1120141312), e(1.0f, 1065353216), e(9.0f, 1091567616), e(27.0f, 1104674816), e(47.0f, 1111228416), e(80.0f, 1117782016), 
        e(13.0f, 1095761920), e(38.0f, 1108869120), e(63.0f, 1115422720), e(87.0f, 1118699520), e(2.0f, 1073741824), e(18.0f, 1099956224), e(54.0f, 1113063424), e(69.0f, 1116340224), e(94.0f, 1119617024), e(3.0f, 1077936128), 
        e(26.0f, 1104150528), e(45.0f, 1110704128), e(76.0f, 1117257728), e(4.0f, 1082130432), e(36.0f, 1108344832), e(61.0f, 1114898432), e(83.0f, 1118175232), e(6.0f, 1086324736), e(17.0f, 1099431936), e(52.0f, 1112539136), 
        e(65.0f, 1115815936), e(90.0f, 1119092736), e(8.0f, 1090519040), e(25.0f, 1103626240), e(43.0f, 1110179840), e(72.0f, 1116733440), e(97.0f, 1120010240), e(12.0f, 1094713344), e(34.0f, 1107820544), e(59.0f, 1114374144), 
        e(79.0f, 1117650944), e(16.0f, 1098907648), e(50.0f, 1112014848), e(86.0f, 1118568448), e(24.0f, 1103101952), e(41.0f, 1109655552), e(68.0f, 1116209152), e(93.0f, 1119485952), e(32.0f, 1107296256), e(57.0f, 1113849856), 
        e(75.0f, 1117126656), e(48.0f, 1111490560), e(82.0f, 1118044160), e(23.0f, 1102577664), e(39.0f, 1109131264), e(64.0f, 1115684864), e(89.0f, 1118961664), e(11.0f, 1093664768), e(31.0f, 1106771968), e(55.0f, 1113325568), 
        e(71.0f, 1116602368), e(96.0f, 1119879168), e(15.0f, 1097859072), e(46.0f, 1110966272), e(78.0f, 1117519872), e(22.0f, 1102053376), e(37.0f, 1108606976), e(62.0f, 1115160576), e(85.0f, 1118437376), e(30.0f, 1106247680), 
        e(53.0f, 1112801280), e(67.0f, 1116078080), e(92.0f, 1119354880), e(5.0f, 1084227584), e(44.0f, 1110441984), e(74.0f, 1116995584), e(99.0f, 1120272384), e(7.0f, 1088421888), e(21.0f, 1101529088), e(35.0f, 1108082688), 
        e(60.0f, 1114636288), e(81.0f, 1117913088), e(10.0f, 1092616192), e(29.0f, 1105723392), e(51.0f, 1112276992), e(88.0f, 1118830592), e(14.0f, 1096810496), e(42.0f, 1109917696), e(70.0f, 1116471296), e(95.0f, 1119748096)
    };

    static uint64_t get_hash(const float value) noexcept
    {
        uint32_t bits;
        std::memcpy(&bits, &value, sizeof(bits));
        if (((bits - 1) & ~0x80000000u) >= 0x7F800000u)
            bits &= 0x7F800000u;
        return bits;
    }

public:
    [[nodiscard]]
    static constexpr bool contains(const float key) noexcept {
        if (key < 0.0f || key > 99.0f)
            return false;


        const uint64_t hash = get_hash(key);
        const size_t index = hash % 100;
        const size_t start = static_cast<size_t>(bucket_starts[index]);
        const size_t count = static_cast<size_t>(bucket_counts[index]);
        const size_t end = start + count;

        for (size_t i = start; i < end; i++) {
            const auto& entry = entries[i];

            if (entry.hash_code == hash && entry.key == key)
                return true;
        }

        return false;
    }

    static constexpr size_t item_count = 100;
    static constexpr float min_key = 0.0f;
    static constexpr float max_key = 99.0f;
};