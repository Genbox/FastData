// This file is auto-generated. Do not edit manually.
// Structure: EliasFano
#pragma once
#include <array>
#include <cstring>
#include <cstdint>
#include <limits>
#include <string_view>

class EliasFanoStructure_Int32_1000_natural_sparse final {
    static constexpr int32_t lower_bit_count = 5;
    static constexpr std::array<uint64_t, 35> upper_bits = {
        0, 0, 0, 0, 0, 8569998247165165568ull, 13505994968989940663ull, 13121086807930026043ull, 7178733607867ull, 8572282884688183296ull, 
        8017373763884250893ull, 8626345266874530775ull, 114843099ull, 8563716590631608320ull, 8606077467601124215ull, 4861485018049613239ull, 6917529027641082743ull, 7993570332096837495ull, 16751963369270632827ull, 265391556270995382ull, 
        17252674445944815616ull, 17730371410552387638ull, 8570048300139133806ull, 3151895837623ull, 17132517322838245376ull, 7993567941276448494ull, 1654753857512159095ull, 31160182ull, 17248150737747666944ull, 14082156645215274934ull, 
        8565249309840735086ull, 16717361816799281527ull, 15590861283333202286ull, 7916723541758146286ull, 24545834871ull
    };

    static constexpr std::array<uint64_t, 79> lower_bits = {
        13381157542753010415ull, 5259608392997391241ull, 8278300478900102390ull, 6430456644257046673ull, 8661777615979087666ull, 4741329775448022559ull, 18429273440410558711ull, 10970153460314561856ull, 10903284999962971405ull, 15223127904740104680ull, 
        13148863654793060072ull, 1151801467238817559ull, 14395173049126421404ull, 7054611735073078946ull, 5740033379695440593ull, 7832982931856408661ull, 17894879870264318184ull, 2754544002549051455ull, 13625427461182034777ull, 16489447962146853899ull, 
        6125721526290708006ull, 6740632697962226563ull, 17933568190195004385ull, 9070409572135365850ull, 11184335873243103096ull, 10366757993120053403ull, 3325599644650983268ull, 10653585939564988695ull, 11767076348912235301ull, 2074300112330154491ull, 
        18167213940925665140ull, 9501758702200673295ull, 8431863336021577945ull, 3836682911469117065ull, 7467633665883893389ull, 18428823475821080955ull, 8961839901508663744ull, 2193323318911953452ull, 18053621551963254038ull, 14647262467445228884ull, 
        9616916818585816710ull, 7179215893365720527ull, 15092654568107488658ull, 5576750433282900155ull, 5777824052103570030ull, 6681261138144802869ull, 10235929937476795924ull, 15999344638198992303ull, 12928677308572891015ull, 18294175300244441529ull, 
        16289366044209116744ull, 4436678369653854578ull, 3805780845500248665ull, 14742057723572979642ull, 13974261949167368001ull, 4454195716505288959ull, 5782604860378385816ull, 6046694362377218199ull, 8801674211884984341ull, 18160014507494021046ull, 
        14262229915956386831ull, 16646429028881703623ull, 13345734027394601313ull, 12995270594609042767ull, 6296716507696654444ull, 4186989851602869496ull, 1674800131495647526ull, 15442191721967127485ull, 211464465109362404ull, 14666457841769087829ull, 
        16200926409952297541ull, 16181841252959705848ull, 3944653260232554621ull, 16005643698267790235ull, 6987125693839533199ull, 15646621693333018422ull, 5552261306875323795ull, 14511994689465383843ull, 28ull
    };

    static constexpr uint64_t lower_mask = 31ull;

    static constexpr int32_t sample_rate_shift = 7;
    static constexpr std::array<int32_t, 10> sample_positions = {
        0, 128, 256, 424, 709, 997, 1276, 1531, 1786, 2041
    };

    static constexpr int popcount(uint64_t value) noexcept {
        int count = 0;
        while (value != 0) {
            count += static_cast<int>(value & 1ULL);
            value >>= 1;
        }
        return count;
    }

    static constexpr int trailing_zero_count(uint64_t value) noexcept {
        if (value == 0) {
            return 64;
        }

        int count = 0;
        while ((value & 1ULL) == 0) {
            value >>= 1;
            count++;
        }
        return count;
    }

    static constexpr int select_bit_in_word(uint64_t word, int rank) noexcept {
        if (static_cast<uint32_t>(rank) >= 64u)
            return -1;

        int remaining = rank;
        uint64_t value = word;

        while (remaining > 0) {
            if (value == 0)
                return -1;

            value &= value - 1;
            remaining--;
        }

        if (value == 0)
            return -1;

        return trailing_zero_count(value);
    }

    static constexpr int64_t select_zero(int64_t rank) noexcept {
        if (rank < 0)
            return -1;

        const size_t sample_index = static_cast<size_t>(rank >> sample_rate_shift);
        if (sample_index >= sample_positions.size())
            return -1;

        int64_t zero_rank = static_cast<int64_t>(sample_index) << sample_rate_shift;
        int64_t start_position = sample_positions[sample_index];
        size_t word_index = static_cast<size_t>(start_position >> 6);
        int start_bit = static_cast<int>(start_position & 63);

        for (; word_index < upper_bits.size(); word_index++) {
            const int valid_bits = word_index == upper_bits.size() - 1 ? 35 : 64;
            const uint64_t valid_mask = valid_bits == 64 ? std::numeric_limits<uint64_t>::max() : ((1ULL << valid_bits) - 1);
            uint64_t zeros = ~upper_bits[word_index] & valid_mask;

            if (start_bit > 0) {
                zeros &= ~((1ULL << start_bit) - 1);
                start_bit = 0;
            }

            const int zero_count = popcount(zeros);
            if (zero_count == 0)
                continue;

            if (zero_rank + zero_count > rank) {
                const int rank_in_word = static_cast<int>(rank - zero_rank);
                const int bit_in_word = select_bit_in_word(zeros, rank_in_word);
                return (static_cast<int64_t>(word_index) << 6) + bit_in_word;
            }

            zero_rank += zero_count;
        }

        return -1;
    }

    public:
    [[nodiscard]]
    static constexpr bool contains(const int32_t key) noexcept {
        if ((static_cast<uint32_t>(key) & 4294901760u) != 0)
            return false;


        const int64_t value = static_cast<int64_t>(key);
        const int64_t high = value >> lower_bit_count;

        int64_t position = high == 0 ? 0 : select_zero(high - 1) + 1;
        if (position < 0)
            return false;

        int64_t rank = position - high;
        if (static_cast<uint64_t>(rank) >= item_count)
            return false;

        size_t curr_word = static_cast<size_t>(position >> 6);

        if (curr_word >= upper_bits.size())
            return false;

        uint64_t window = upper_bits[curr_word] & (std::numeric_limits<uint64_t>::max() << static_cast<uint32_t>(position & 63));
        const uint64_t target_low = static_cast<uint64_t>(value) & lower_mask;
        int64_t lower_bits_offset = rank * lower_bit_count;

        while (true) {
            while (window == 0) {
                curr_word++;
                if (curr_word >= upper_bits.size())
                    return false;

                window = upper_bits[curr_word];
            }

            const int trailing = trailing_zero_count(window);
            const int64_t one_position = (static_cast<int64_t>(curr_word) << 6) + trailing;
            const int64_t current_high = one_position - rank;

            if (current_high >= high) {
                if (current_high > high)
                    return false;

                const size_t word_index = static_cast<size_t>(lower_bits_offset >> 6);
                const int start_bit = static_cast<int>(lower_bits_offset & 63);

                uint64_t current_low = 0;
                if (start_bit + lower_bit_count <= 64)
                    current_low = (lower_bits[word_index] >> start_bit) & lower_mask;
                else {
                    const uint64_t lower = lower_bits[word_index] >> start_bit;
                    const uint64_t upper = lower_bits[word_index + 1] << (64 - start_bit);
                    current_low = (lower | upper) & lower_mask;
                }

                if (current_low == target_low)
                    return true;

                if (current_low > target_low)
                    return false;
            }

            window &= window - 1;
            rank++;

            if (static_cast<uint64_t>(rank) >= item_count)
                return false;

            lower_bits_offset += lower_bit_count;
        }
    }

    static constexpr size_t item_count = 1000;
    static constexpr int32_t min_key = 11727;
    static constexpr int32_t max_key = 38755;
};