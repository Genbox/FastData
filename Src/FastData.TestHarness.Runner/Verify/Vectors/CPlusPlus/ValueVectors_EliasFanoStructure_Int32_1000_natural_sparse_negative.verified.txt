// This file is auto-generated. Do not edit manually.
// Structure: EliasFano
#pragma once
#include <array>
#include <cstring>
#include <cstdint>
#include <limits>
#include <string_view>

class EliasFanoStructure_Int32_1000_natural_sparse_negative final {
    static constexpr int32_t lower_bit_count = 4;
    static constexpr int64_t min_value = -198273ll;
    static constexpr int64_t max_value = -171245ll;
    static constexpr int64_t max_value_normalized = 27028ll;
    static constexpr std::array<uint64_t, 43> upper_bits = {
        11535226534270511963ull, 12106474960098863798ull, 6125096337533130166ull, 234237026632379757ull, 0, 13066832212270252032ull, 13066470108627522901ull, 7686357402408463021ull, 6150468668486583659ull, 111804763ull, 
        0, 6149669047885452651ull, 12310028189108448091ull, 12298627261436439222ull, 391144710509778358ull, 0, 15756642456625479680ull, 13066832213171322906ull, 13066470108638652421ull, 7686357402409855489ull, 
        190142080ull, 0, 7686355942026095277ull, 6150468485180642667ull, 12310261171220032347ull, 769458801468943030ull, 0, 816659418262274048ull, 192202145890216624ull, 24407692306372020ull, 
        11535246235332685165ull, 190147434ull, 0, 13066470107876087125ull, 7686357402220604077ull, 6150468668431357291ull, 781046153792760667ull, 0, 6053589320894251008ull, 12285920297157831515ull, 
        12294852088262470326ull, 6154176221064549814ull, 1ull
    };

    static constexpr std::array<uint64_t, 63> lower_bits = {
        12636060196807291264ull, 14147968314379338038ull, 4109552257374051405ull, 125581634409093038ull, 15331735649828538384ull, 6315930693306793511ull, 9266307683119842628ull, 13702021880517437105ull, 5606100993449171081ull, 2788159246640263004ull, 
        1153263106379336927ull, 12636059610418919688ull, 4924596277524562230ull, 4109552294006609093ull, 9925414423567292334ull, 15331735647554732184ull, 16079734685446028839ull, 9266307683246165452ull, 3940469688191887025ull, 5606100993441271809ull, 
        12554074301104828252ull, 1153263106378777687ull, 2870135759861332232ull, 4924596277524597182ull, 12790390659100431557ull, 9925414423567294246ull, 6651197483495030936ull, 16079734685446028975ull, 580965686312717772ull, 3940469688191887033ull, 
        14214582729680883713ull, 12554074301104828252ull, 1768153407002330199ull, 2870135759861332232ull, 4962727858194123198ull, 12790390659100431557ull, 9923311639934590758ull, 6651197483495030936ull, 16079602226363971247ull, 580965686312717772ull, 
        3940461405204360761ull, 14214582729680883713ull, 12554074887510960084ull, 10991525443857106007ull, 2870135796493889920ull, 14762560647352322494ull, 12790390656827612237ull, 87450053757427494ull, 6651197483621353488ull, 6318050034038421167ull, 
        580965686320612676ull, 13702154335018266169ull, 14214582729680394377ull, 2788151036953372628ull, 10991525443857140959ull, 12636060196807291264ull, 14762560647352320310ull, 4109552257374051405ull, 87450053757427630ull, 15331735649828538384ull, 
        6318050034038421159ull, 9266307683119842628ull, 1146596921ull
    };

    static constexpr uint64_t lower_mask = 15ull;

    static constexpr int32_t sample_rate_shift = 7;
    static constexpr std::array<int32_t, 14> sample_positions = {
        0, 255, 417, 638, 830, 1021, 1245, 1404, 1658, 1813, 
        2042, 2228, 2425, 2641
    };

    static constexpr int popcount(uint64_t value) noexcept {
        int count = 0;
        while (value != 0) {
            count += static_cast<int>(value & 1ULL);
            value >>= 1;
        }
        return count;
    }

    static constexpr int trailing_zero_count(uint64_t value) noexcept {
        if (value == 0) {
            return 64;
        }

        int count = 0;
        while ((value & 1ULL) == 0) {
            value >>= 1;
            count++;
        }
        return count;
    }

    static constexpr int select_bit_in_word(uint64_t word, int rank) noexcept {
        if (static_cast<uint32_t>(rank) >= 64u)
            return -1;

        int remaining = rank;
        uint64_t value = word;

        while (remaining > 0) {
            if (value == 0)
                return -1;

            value &= value - 1;
            remaining--;
        }

        if (value == 0)
            return -1;

        return trailing_zero_count(value);
    }

    static constexpr int64_t select_zero(int64_t rank) noexcept {
        if (rank < 0)
            return -1;

        const size_t sample_index = static_cast<size_t>(rank >> sample_rate_shift);
        if (sample_index >= sample_positions.size())
            return -1;

        int64_t zero_rank = static_cast<int64_t>(sample_index) << sample_rate_shift;
        int64_t start_position = sample_positions[sample_index];
        size_t word_index = static_cast<size_t>(start_position >> 6);
        int start_bit = static_cast<int>(start_position & 63);

        for (; word_index < upper_bits.size(); word_index++) {
            const int valid_bits = word_index == upper_bits.size() - 1 ? 1 : 64;
            const uint64_t valid_mask = valid_bits == 64 ? std::numeric_limits<uint64_t>::max() : ((1ULL << valid_bits) - 1);
            uint64_t zeros = ~upper_bits[word_index] & valid_mask;

            if (start_bit > 0) {
                zeros &= ~((1ULL << start_bit) - 1);
                start_bit = 0;
            }

            const int zero_count = popcount(zeros);
            if (zero_count == 0)
                continue;

            if (zero_rank + zero_count > rank) {
                const int rank_in_word = static_cast<int>(rank - zero_rank);
                const int bit_in_word = select_bit_in_word(zeros, rank_in_word);
                return (static_cast<int64_t>(word_index) << 6) + bit_in_word;
            }

            zero_rank += zero_count;
        }

        return -1;
    }

    public:
    [[nodiscard]]
    static constexpr bool contains(const int32_t key) noexcept {
        if (key < -198273 || key > -171245)
            return false;


        const int64_t value = static_cast<int64_t>(key) - min_value;
        if (static_cast<uint64_t>(value) > static_cast<uint64_t>(max_value_normalized))
            return false;
        const int64_t high = value >> lower_bit_count;

        int64_t position = high == 0 ? 0 : select_zero(high - 1) + 1;
        if (position < 0)
            return false;

        int64_t rank = position - high;
        if (static_cast<uint64_t>(rank) >= item_count)
            return false;

        size_t curr_word = static_cast<size_t>(position >> 6);

        if (curr_word >= upper_bits.size())
            return false;

        uint64_t window = upper_bits[curr_word] & (std::numeric_limits<uint64_t>::max() << static_cast<uint32_t>(position & 63));
        const uint64_t target_low = static_cast<uint64_t>(value) & lower_mask;
        int64_t lower_bits_offset = rank * lower_bit_count;

        while (true) {
            while (window == 0) {
                curr_word++;
                if (curr_word >= upper_bits.size())
                    return false;

                window = upper_bits[curr_word];
            }

            const int trailing = trailing_zero_count(window);
            const int64_t one_position = (static_cast<int64_t>(curr_word) << 6) + trailing;
            const int64_t current_high = one_position - rank;

            if (current_high >= high) {
                if (current_high > high)
                    return false;

                const size_t word_index = static_cast<size_t>(lower_bits_offset >> 6);
                const int start_bit = static_cast<int>(lower_bits_offset & 63);

                uint64_t current_low = 0;
                if (start_bit + lower_bit_count <= 64)
                    current_low = (lower_bits[word_index] >> start_bit) & lower_mask;
                else {
                    const uint64_t lower = lower_bits[word_index] >> start_bit;
                    const uint64_t upper = lower_bits[word_index + 1] << (64 - start_bit);
                    current_low = (lower | upper) & lower_mask;
                }

                if (current_low == target_low)
                    return true;

                if (current_low > target_low)
                    return false;
            }

            window &= window - 1;
            rank++;

            if (static_cast<uint64_t>(rank) >= item_count)
                return false;

            lower_bits_offset += lower_bit_count;
        }
    }

    static constexpr size_t item_count = 1000;
    static constexpr int32_t min_key = -198273;
    static constexpr int32_t max_key = -171245;
};