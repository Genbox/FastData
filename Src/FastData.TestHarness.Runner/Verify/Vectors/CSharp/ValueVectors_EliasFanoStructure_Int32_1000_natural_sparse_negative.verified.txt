// <auto-generated />
// This file is auto-generated. Do not edit manually.
// Structure: EliasFano
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class EliasFanoStructure_Int32_1000_natural_sparse_negative
{
    private const int _lowerBitCount = 4;
    private const long _minValue = -198273l;
    private const long _maxValue = -171245l;
    private const long _maxValueNormalized = 27028l;
    private static readonly ulong[] _upperBits = new ulong[] {
        11535226534270511963ul, 12106474960098863798ul, 6125096337533130166ul, 234237026632379757ul, ulong.MinValue, 13066832212270252032ul, 13066470108627522901ul, 7686357402408463021ul, 6150468668486583659ul, 111804763ul, 
        ulong.MinValue, 6149669047885452651ul, 12310028189108448091ul, 12298627261436439222ul, 391144710509778358ul, ulong.MinValue, 15756642456625479680ul, 13066832213171322906ul, 13066470108638652421ul, 7686357402409855489ul, 
        190142080ul, ulong.MinValue, 7686355942026095277ul, 6150468485180642667ul, 12310261171220032347ul, 769458801468943030ul, ulong.MinValue, 816659418262274048ul, 192202145890216624ul, 24407692306372020ul, 
        11535246235332685165ul, 190147434ul, ulong.MinValue, 13066470107876087125ul, 7686357402220604077ul, 6150468668431357291ul, 781046153792760667ul, ulong.MinValue, 6053589320894251008ul, 12285920297157831515ul, 
        12294852088262470326ul, 6154176221064549814ul, 1ul
    };

    private static readonly ulong[] _lowerBits = new ulong[] {
        12636060196807291264ul, 14147968314379338038ul, 4109552257374051405ul, 125581634409093038ul, 15331735649828538384ul, 6315930693306793511ul, 9266307683119842628ul, 13702021880517437105ul, 5606100993449171081ul, 2788159246640263004ul, 
        1153263106379336927ul, 12636059610418919688ul, 4924596277524562230ul, 4109552294006609093ul, 9925414423567292334ul, 15331735647554732184ul, 16079734685446028839ul, 9266307683246165452ul, 3940469688191887025ul, 5606100993441271809ul, 
        12554074301104828252ul, 1153263106378777687ul, 2870135759861332232ul, 4924596277524597182ul, 12790390659100431557ul, 9925414423567294246ul, 6651197483495030936ul, 16079734685446028975ul, 580965686312717772ul, 3940469688191887033ul, 
        14214582729680883713ul, 12554074301104828252ul, 1768153407002330199ul, 2870135759861332232ul, 4962727858194123198ul, 12790390659100431557ul, 9923311639934590758ul, 6651197483495030936ul, 16079602226363971247ul, 580965686312717772ul, 
        3940461405204360761ul, 14214582729680883713ul, 12554074887510960084ul, 10991525443857106007ul, 2870135796493889920ul, 14762560647352322494ul, 12790390656827612237ul, 87450053757427494ul, 6651197483621353488ul, 6318050034038421167ul, 
        580965686320612676ul, 13702154335018266169ul, 14214582729680394377ul, 2788151036953372628ul, 10991525443857140959ul, 12636060196807291264ul, 14762560647352320310ul, 4109552257374051405ul, 87450053757427630ul, 15331735649828538384ul, 
        6318050034038421159ul, 9266307683119842628ul, 1146596921ul
    };

    private const ulong _lowerMask = 15ul;

    private const int _sampleRateShift = 7;
    private static readonly int[] _samplePositions = new int[] {
        0, 255, 417, 638, 830, 1021, 1245, 1404, 1658, 1813, 
        2042, 2228, 2425, 2641
    };


    public static bool Contains(int key)
    {
        if (key < -198273 || key > -171245)
            return false;


        long value = (long)key - _minValue;
        if ((ulong)value > (ulong)_maxValueNormalized)
            return false;
        long high = value >> _lowerBitCount;

        long position = high == 0 ? 0 : SelectZero(high - 1) + 1;
        if (position < 0)
            return false;

        long rank = position - high;
        if ((ulong)rank >= ItemCount)
            return false;

        int currWord = (int)(position >> 6);

        if ((uint)currWord >= (uint)_upperBits.Length)
            return false;

        ulong window = _upperBits[currWord] & (ulong.MaxValue << (int)(position & 63));
        ulong targetLow = (ulong)value & _lowerMask;
        long lowerBitsOffset = rank * _lowerBitCount;

        while (true)
        {
            while (window == 0)
            {
                currWord++;
                if ((uint)currWord >= (uint)_upperBits.Length)
                    return false;

                window = _upperBits[currWord];
            }

            int trailing = System.Numerics.BitOperations.TrailingZeroCount(window);
            long onePosition = ((long)currWord << 6) + trailing;
            long currentHigh = onePosition - rank;

            if (currentHigh >= high)
            {
                if (currentHigh > high)
                    return false;

                int wordIndex = (int)(lowerBitsOffset >> 6);
                int startBit = (int)(lowerBitsOffset & 63);

                ulong currentLow;
                if (startBit + _lowerBitCount <= 64)
                    currentLow = (_lowerBits[wordIndex] >> startBit) & _lowerMask;
                else
                {
                    ulong lower = _lowerBits[wordIndex] >> startBit;
                    ulong upper = _lowerBits[wordIndex + 1] << (64 - startBit);
                    currentLow = (lower | upper) & _lowerMask;
                }

                if (currentLow == targetLow)
                    return true;

                if (currentLow > targetLow)
                    return false;
            }

            window &= window - 1;
            rank++;

            if ((ulong)rank >= ItemCount)
                return false;

            lowerBitsOffset += _lowerBitCount;
        }
    }

    private static long SelectZero(long rank)
    {
        if (rank < 0)
            return -1;

        int sampleIndex = (int)(rank >> _sampleRateShift);
        if ((uint)sampleIndex >= (uint)_samplePositions.Length)
            return -1;

        long zeroRank = (long)sampleIndex << _sampleRateShift;
        int startPosition = _samplePositions[sampleIndex];
        int wordIndex = startPosition >> 6;
        int startBit = startPosition & 63;

        for (; wordIndex < _upperBits.Length; wordIndex++)
        {
            int validBits = wordIndex == _upperBits.Length - 1 ? 1 : 64;
            ulong validMask = validBits == 64 ? ulong.MaxValue : (1UL << validBits) - 1;
            ulong zeros = ~_upperBits[wordIndex] & validMask;

            if (startBit > 0)
            {
                zeros &= ~((1UL << startBit) - 1);
                startBit = 0;
            }

            int zeroCount = System.Numerics.BitOperations.PopCount(zeros);
            if (zeroCount == 0)
                continue;

            if (zeroRank + zeroCount > rank)
            {
                int rankInWord = (int)(rank - zeroRank);
                int bitInWord = SelectBitInWord(zeros, rankInWord);
                return ((long)wordIndex << 6) + bitInWord;
            }

            zeroRank += zeroCount;
        }

        return -1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int SelectBitInWord(ulong word, int rank)
    {
        if ((uint)rank >= 64)
            return -1;

        int remaining = rank;
        ulong value = word;

        while (remaining > 0)
        {
            if (value == 0)
                return -1;

            value &= value - 1;
            remaining--;
        }

        if (value == 0)
            return -1;

        return System.Numerics.BitOperations.TrailingZeroCount(value);
    }

    public const uint ItemCount = 1000;
    public const int MinKey = -198273;
    public const int MaxKey = -171245;
}