// <auto-generated />
// This file is auto-generated. Do not edit manually.
// Structure: EliasFano
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class EliasFanoStructure_Int32_1000_natural_sparse
{
    private const int _lowerBitCount = 5;
    private static readonly ulong[] _upperBits = new ulong[] {
        ulong.MinValue, ulong.MinValue, ulong.MinValue, ulong.MinValue, ulong.MinValue, 8569998247165165568ul, 13505994968989940663ul, 13121086807930026043ul, 7178733607867ul, 8572282884688183296ul, 
        8017373763884250893ul, 8626345266874530775ul, 114843099ul, 8563716590631608320ul, 8606077467601124215ul, 4861485018049613239ul, 6917529027641082743ul, 7993570332096837495ul, 16751963369270632827ul, 265391556270995382ul, 
        17252674445944815616ul, 17730371410552387638ul, 8570048300139133806ul, 3151895837623ul, 17132517322838245376ul, 7993567941276448494ul, 1654753857512159095ul, 31160182ul, 17248150737747666944ul, 14082156645215274934ul, 
        8565249309840735086ul, 16717361816799281527ul, 15590861283333202286ul, 7916723541758146286ul, 24545834871ul
    };

    private static readonly ulong[] _lowerBits = new ulong[] {
        13381157542753010415ul, 5259608392997391241ul, 8278300478900102390ul, 6430456644257046673ul, 8661777615979087666ul, 4741329775448022559ul, 18429273440410558711ul, 10970153460314561856ul, 10903284999962971405ul, 15223127904740104680ul, 
        13148863654793060072ul, 1151801467238817559ul, 14395173049126421404ul, 7054611735073078946ul, 5740033379695440593ul, 7832982931856408661ul, 17894879870264318184ul, 2754544002549051455ul, 13625427461182034777ul, 16489447962146853899ul, 
        6125721526290708006ul, 6740632697962226563ul, 17933568190195004385ul, 9070409572135365850ul, 11184335873243103096ul, 10366757993120053403ul, 3325599644650983268ul, 10653585939564988695ul, 11767076348912235301ul, 2074300112330154491ul, 
        18167213940925665140ul, 9501758702200673295ul, 8431863336021577945ul, 3836682911469117065ul, 7467633665883893389ul, 18428823475821080955ul, 8961839901508663744ul, 2193323318911953452ul, 18053621551963254038ul, 14647262467445228884ul, 
        9616916818585816710ul, 7179215893365720527ul, 15092654568107488658ul, 5576750433282900155ul, 5777824052103570030ul, 6681261138144802869ul, 10235929937476795924ul, 15999344638198992303ul, 12928677308572891015ul, 18294175300244441529ul, 
        16289366044209116744ul, 4436678369653854578ul, 3805780845500248665ul, 14742057723572979642ul, 13974261949167368001ul, 4454195716505288959ul, 5782604860378385816ul, 6046694362377218199ul, 8801674211884984341ul, 18160014507494021046ul, 
        14262229915956386831ul, 16646429028881703623ul, 13345734027394601313ul, 12995270594609042767ul, 6296716507696654444ul, 4186989851602869496ul, 1674800131495647526ul, 15442191721967127485ul, 211464465109362404ul, 14666457841769087829ul, 
        16200926409952297541ul, 16181841252959705848ul, 3944653260232554621ul, 16005643698267790235ul, 6987125693839533199ul, 15646621693333018422ul, 5552261306875323795ul, 14511994689465383843ul, 28ul
    };

    private const ulong _lowerMask = 31ul;

    private const int _sampleRateShift = 7;
    private static readonly int[] _samplePositions = new int[] {
        0, 128, 256, 424, 709, 997, 1276, 1531, 1786, 2041
    };


    public static bool Contains(int key)
    {
        if (((uint)key & 4294901760u) != 0)
            return false;


        long value = (long)key;
        long high = value >> _lowerBitCount;

        long position = high == 0 ? 0 : SelectZero(high - 1) + 1;
        if (position < 0)
            return false;

        long rank = position - high;
        if ((ulong)rank >= ItemCount)
            return false;

        int currWord = (int)(position >> 6);

        if ((uint)currWord >= (uint)_upperBits.Length)
            return false;

        ulong window = _upperBits[currWord] & (ulong.MaxValue << (int)(position & 63));
        ulong targetLow = (ulong)value & _lowerMask;
        long lowerBitsOffset = rank * _lowerBitCount;

        while (true)
        {
            while (window == 0)
            {
                currWord++;
                if ((uint)currWord >= (uint)_upperBits.Length)
                    return false;

                window = _upperBits[currWord];
            }

            int trailing = System.Numerics.BitOperations.TrailingZeroCount(window);
            long onePosition = ((long)currWord << 6) + trailing;
            long currentHigh = onePosition - rank;

            if (currentHigh >= high)
            {
                if (currentHigh > high)
                    return false;

                int wordIndex = (int)(lowerBitsOffset >> 6);
                int startBit = (int)(lowerBitsOffset & 63);

                ulong currentLow;
                if (startBit + _lowerBitCount <= 64)
                    currentLow = (_lowerBits[wordIndex] >> startBit) & _lowerMask;
                else
                {
                    ulong lower = _lowerBits[wordIndex] >> startBit;
                    ulong upper = _lowerBits[wordIndex + 1] << (64 - startBit);
                    currentLow = (lower | upper) & _lowerMask;
                }

                if (currentLow == targetLow)
                    return true;

                if (currentLow > targetLow)
                    return false;
            }

            window &= window - 1;
            rank++;

            if ((ulong)rank >= ItemCount)
                return false;

            lowerBitsOffset += _lowerBitCount;
        }
    }

    private static long SelectZero(long rank)
    {
        if (rank < 0)
            return -1;

        int sampleIndex = (int)(rank >> _sampleRateShift);
        if ((uint)sampleIndex >= (uint)_samplePositions.Length)
            return -1;

        long zeroRank = (long)sampleIndex << _sampleRateShift;
        int startPosition = _samplePositions[sampleIndex];
        int wordIndex = startPosition >> 6;
        int startBit = startPosition & 63;

        for (; wordIndex < _upperBits.Length; wordIndex++)
        {
            int validBits = wordIndex == _upperBits.Length - 1 ? 35 : 64;
            ulong validMask = validBits == 64 ? ulong.MaxValue : (1UL << validBits) - 1;
            ulong zeros = ~_upperBits[wordIndex] & validMask;

            if (startBit > 0)
            {
                zeros &= ~((1UL << startBit) - 1);
                startBit = 0;
            }

            int zeroCount = System.Numerics.BitOperations.PopCount(zeros);
            if (zeroCount == 0)
                continue;

            if (zeroRank + zeroCount > rank)
            {
                int rankInWord = (int)(rank - zeroRank);
                int bitInWord = SelectBitInWord(zeros, rankInWord);
                return ((long)wordIndex << 6) + bitInWord;
            }

            zeroRank += zeroCount;
        }

        return -1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int SelectBitInWord(ulong word, int rank)
    {
        if ((uint)rank >= 64)
            return -1;

        int remaining = rank;
        ulong value = word;

        while (remaining > 0)
        {
            if (value == 0)
                return -1;

            value &= value - 1;
            remaining--;
        }

        if (value == 0)
            return -1;

        return System.Numerics.BitOperations.TrailingZeroCount(value);
    }

    public const uint ItemCount = 1000;
    public const int MinKey = 11727;
    public const int MaxKey = 38755;
}