// <auto-generated />
// This file is auto-generated. Do not edit manually.
// Structure: HashTableCompact
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class HashTableCompactStructure_Int32_100
{
    [StructLayout(LayoutKind.Auto)]
    private struct E
    {
        internal int Key;
        internal E(int key)
        {
            Key = key;
        }
    };

    private static readonly byte[] _bucketStarts = new byte[] {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 
        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 
        90, 91, 92, 93, 94, 95, 96, 97, 98, 99
    };

    private static readonly byte[] _bucketCounts = new byte[] {
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

    private static readonly E[] _entries = {
        new E(0), new E(1), new E(2), new E(3), new E(4), new E(5), new E(6), new E(7), new E(8), new E(9), 
        new E(10), new E(11), new E(12), new E(13), new E(14), new E(15), new E(16), new E(17), new E(18), new E(19), 
        new E(20), new E(21), new E(22), new E(23), new E(24), new E(25), new E(26), new E(27), new E(28), new E(29), 
        new E(30), new E(31), new E(32), new E(33), new E(34), new E(35), new E(36), new E(37), new E(38), new E(39), 
        new E(40), new E(41), new E(42), new E(43), new E(44), new E(45), new E(46), new E(47), new E(48), new E(49), 
        new E(50), new E(51), new E(52), new E(53), new E(54), new E(55), new E(56), new E(57), new E(58), new E(59), 
        new E(60), new E(61), new E(62), new E(63), new E(64), new E(65), new E(66), new E(67), new E(68), new E(69), 
        new E(70), new E(71), new E(72), new E(73), new E(74), new E(75), new E(76), new E(77), new E(78), new E(79), 
        new E(80), new E(81), new E(82), new E(83), new E(84), new E(85), new E(86), new E(87), new E(88), new E(89), 
        new E(90), new E(91), new E(92), new E(93), new E(94), new E(95), new E(96), new E(97), new E(98), new E(99)
    };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ulong Hash(int value)
    {
        return (ulong)value;
    }


    public static bool Contains(int key)
    {
        if (((uint)key & 4294967168u) != 0)
            return false;


        ulong hash = Hash(key);
        uint index = (uint)(hash % 100);
        int start = (int)_bucketStarts[index];
        int count = (int)_bucketCounts[index];
        int end = start + count;

        for (int i = start; i < end; i++)
        {
            ref E entry = ref _entries[i];

            if (entry.Key == key)
                return true;
        }

        return false;
    }

    public const uint ItemCount = 100;
    public const int MinKey = 0;
    public const int MaxKey = 99;
}