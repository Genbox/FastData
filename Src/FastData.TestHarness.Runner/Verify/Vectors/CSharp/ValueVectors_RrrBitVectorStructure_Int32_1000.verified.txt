// <auto-generated />
// This file is auto-generated. Do not edit manually.
// Structure: RrrBitVector
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class RrrBitVectorStructure_Int32_1000
{
    private static readonly ulong _rrrMinValue = 2147483648ul;
    private static readonly ulong _rrrMaxValue = 2147484647ul;
    private static readonly int _rrrBlockSize = 15;
    private static readonly byte[] _rrrClasses = new byte[] {
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
        15, 15, 15, 15, 15, 15, 10
    };
    private static readonly uint[] _rrrOffsets = new uint[] {
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, 
        uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue, uint.MinValue
    };

              
              public static bool Contains(int key)
    {
        if (((uint)key & 4294966272u) != 0)
            return false;


        ulong mapped = (ulong)(uint)(key ^ int.MinValue);

        if (mapped < _rrrMinValue || mapped > _rrrMaxValue)
            return false;

        ulong normalized = mapped - _rrrMinValue;
        int blockIndex = (int)(normalized / (ulong)_rrrBlockSize);
        int bitInBlock = (int)(normalized % (ulong)_rrrBlockSize);
        int classValue = _rrrClasses[blockIndex];

        if (classValue == 0)
            return false;

        uint rank = _rrrOffsets[blockIndex];
        return DecodeBit(classValue, rank, bitInBlock);
    }

    private static bool DecodeBit(int classValue, uint rank, int targetBit)
    {
        int remaining = classValue;

        for (int bit = _rrrBlockSize - 1; bit >= 0; bit--)
        {
            if (remaining == 0)
                return false;

            int comb = Binomial(bit, remaining);
            bool isSet;

            if (rank >= (uint)comb)
            {
                rank -= (uint)comb;
                remaining--;
                isSet = true;
            }
            else
                isSet = false;

            if (bit == targetBit)
                return isSet;
        }

        return false;
    }

    private static int Binomial(int n, int k)
    {
        if (k < 0 || k > n)
            return 0;

        if (k == 0 || k == n)
            return 1;

        if (k > n - k)
            k = n - k;

        int result = 1;

        for (int i = 1; i <= k; i++)
            result = checked(result * (n - (k - i)) / i);

        return result;
    }

    public const uint ItemCount = 1000;
    public const int MinKey = 0;
    public const int MaxKey = 999;
}