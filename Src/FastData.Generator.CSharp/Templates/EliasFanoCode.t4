<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>

<#@ parameter type="Genbox.FastData.Generator.CSharp.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.EliasFanoContext" name="Context" #>

private const int _lowerBitCount = <#= Context.LowerBitCount #>;
<#= Model.FieldModifier #>ulong[] _upperBits = new ulong[] {
<#= FormatHelper.FormatColumns(Context.UpperBits, x => Model.ToValueLabel(x)) #>
};
<#
    if (Context.LowerBitCount != 0)
    {
#>

<#= Model.FieldModifier #>ulong[] _lowerBits = new ulong[] {
<#= FormatHelper.FormatColumns(Context.LowerBits, x => Model.ToValueLabel(x)) #>
};

private const ulong _lowerMask = <#= Model.ToValueLabel(Context.LowerMask) #>;
<#
    }
#>

private const int _sampleRateShift = <#= Context.SampleRateShift #>;
<#= Model.FieldModifier #>int[] _samplePositions = new int[] {
<#= FormatHelper.FormatColumns(Context.SamplePositions, x => Model.ToValueLabel(x)) #>
};

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>bool Contains(<#= Model.KeyTypeName #> <#= Common.InputKeyName #>)
{
<#= Model.GetMethodHeader(MethodType.Contains) #>

    long value = (long)<#= Common.LookupKeyName #>;
    long high = value >> _lowerBitCount;

    long position = high == 0 ? 0 : SelectZero(high - 1) + 1;
    if (position < 0)
        return false;

    long rank = position - high;
    if ((ulong)rank >= ItemCount)
        return false;

    int currWord = (int)(position >> 6);

    if ((uint)currWord >= (uint)_upperBits.Length)
        return false;

    ulong window = _upperBits[currWord] & (ulong.MaxValue << (int)(position & 63));
<#
    if (Context.LowerBitCount != 0)
    {
#>    ulong targetLow = (ulong)value & _lowerMask;
    long lowerBitsOffset = rank * _lowerBitCount;

    while (true)
    {
        while (window == 0)
        {
            currWord++;
            if ((uint)currWord >= (uint)_upperBits.Length)
                return false;

            window = _upperBits[currWord];
        }

        int trailing = System.Numerics.BitOperations.TrailingZeroCount(window);
        long onePosition = ((long)currWord << 6) + trailing;
        long currentHigh = onePosition - rank;

        if (currentHigh >= high)
        {
            if (currentHigh > high)
                return false;

            int wordIndex = (int)(lowerBitsOffset >> 6);
            int startBit = (int)(lowerBitsOffset & 63);

            ulong currentLow;
            if (startBit + _lowerBitCount <= 64)
                currentLow = (_lowerBits[wordIndex] >> startBit) & _lowerMask;
            else
            {
                ulong lower = _lowerBits[wordIndex] >> startBit;
                ulong upper = _lowerBits[wordIndex + 1] << (64 - startBit);
                currentLow = (lower | upper) & _lowerMask;
            }

            if (currentLow == targetLow)
                return true;

            if (currentLow > targetLow)
                return false;
        }

        window &= window - 1;
        rank++;

        if ((ulong)rank >= ItemCount)
            return false;

        lowerBitsOffset += _lowerBitCount;
    }
<#
    }
    else
    {
#>    while (true)
    {
        while (window == 0)
        {
            currWord++;
            if ((uint)currWord >= (uint)_upperBits.Length)
                return false;

            window = _upperBits[currWord];
        }

        int trailing = System.Numerics.BitOperations.TrailingZeroCount(window);
        long onePosition = ((long)currWord << 6) + trailing;
        long currentHigh = onePosition - rank;

        if (currentHigh >= high)
        {
            if (currentHigh > high)
                return false;

            return true;
        }

        window &= window - 1;
        rank++;

        if ((ulong)rank >= ItemCount)
            return false;
    }
<#
    }
#>}

private static long SelectZero(long rank)
{
    if (rank < 0)
        return -1;

    int sampleIndex = (int)(rank >> _sampleRateShift);
    if ((uint)sampleIndex >= (uint)_samplePositions.Length)
        return -1;

    long zeroRank = (long)sampleIndex << _sampleRateShift;
    int startPosition = _samplePositions[sampleIndex];
    int wordIndex = startPosition >> 6;
    int startBit = startPosition & 63;

    for (; wordIndex < _upperBits.Length; wordIndex++)
    {
        int validBits = wordIndex == _upperBits.Length - 1 ? <#= (Context.UpperBitLength & 63) #> : 64;
        ulong validMask = validBits == 64 ? ulong.MaxValue : (1UL << validBits) - 1;
        ulong zeros = ~_upperBits[wordIndex] & validMask;

        if (startBit > 0)
        {
            zeros &= ~((1UL << startBit) - 1);
            startBit = 0;
        }

        int zeroCount = System.Numerics.BitOperations.PopCount(zeros);
        if (zeroCount == 0)
            continue;

        if (zeroRank + zeroCount > rank)
        {
            int rankInWord = (int)(rank - zeroRank);
            int bitInWord = SelectBitInWord(zeros, rankInWord);
            return ((long)wordIndex << 6) + bitInWord;
        }

        zeroRank += zeroCount;
    }

    return -1;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
private static int SelectBitInWord(ulong word, int rank)
{
    if ((uint)rank >= 64)
        return -1;

    int remaining = rank;
    ulong value = word;

    while (remaining > 0)
    {
        if (value == 0)
            return -1;

        value &= value - 1;
        remaining--;
    }

    if (value == 0)
        return -1;

    return System.Numerics.BitOperations.TrailingZeroCount(value);
}