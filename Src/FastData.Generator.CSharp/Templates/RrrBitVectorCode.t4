<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>

<#@ parameter type="Genbox.FastData.Generator.CSharp.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.RrrBitVectorContext" name="Context" #>

<#
    string mapSource = Model.KeyTypeCode switch
    {
        TypeCode.Char or TypeCode.Byte or TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64 => $"(ulong){Common.LookupKeyName}",
        TypeCode.SByte => $"(ulong)(byte)({Common.LookupKeyName} ^ sbyte.MinValue)",
        TypeCode.Int16 => $"(ulong)(ushort)({Common.LookupKeyName} ^ short.MinValue)",
        TypeCode.Int32 => $"(ulong)(uint)({Common.LookupKeyName} ^ int.MinValue)",
        TypeCode.Int64 => $"(ulong)({Common.LookupKeyName} ^ long.MinValue)",
        _ => throw new InvalidOperationException("RRR bitvector only supports integral key types.")
    };

    string helperModifier = Model.FieldModifier.Contains(" static ", StringComparison.Ordinal) ? "private static " : "private ";
#>
private const ulong _rrrMinValue = <#= Model.ToValueLabel(Context.MinValue) #>;
private const ulong _rrrMaxValue = <#= Model.ToValueLabel(Context.MaxValue) #>;
private const int _rrrBlockSize = <#= Context.BlockSize #>;
<#= Model.FieldModifier #>byte[] _rrrClasses = new byte[] {
<#= FormatHelper.FormatColumns(Context.Classes, x => Model.ToValueLabel(x)) #>
};
<#= Model.FieldModifier #>uint[] _rrrOffsets = new uint[] {
<#= FormatHelper.FormatColumns(Context.Offsets, x => Model.ToValueLabel(x)) #>
};

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>bool Contains(<#= Model.KeyTypeName #> <#= Common.InputKeyName #>)
{
<#= Model.GetMethodHeader(MethodType.Contains) #>

    ulong mapped = <#= mapSource #>;

    if (mapped < _rrrMinValue || mapped > _rrrMaxValue)
        return false;

    ulong normalized = mapped - _rrrMinValue;
    int blockIndex = (int)(normalized / (ulong)_rrrBlockSize);
    int bitInBlock = (int)(normalized % (ulong)_rrrBlockSize);
    int classValue = _rrrClasses[blockIndex];

    if (classValue == 0)
        return false;

    uint rank = _rrrOffsets[blockIndex];
    return DecodeBit(classValue, rank, bitInBlock);
}

<#= helperModifier #>bool DecodeBit(int classValue, uint rank, int targetBit)
{
    int remaining = classValue;

    for (int bit = _rrrBlockSize - 1; bit >= 0; bit--)
    {
        if (remaining == 0)
            return false;

        int comb = Binomial(bit, remaining);
        bool isSet;

        if (rank >= (uint)comb)
        {
            rank -= (uint)comb;
            remaining--;
            isSet = true;
        }
        else
            isSet = false;

        if (bit == targetBit)
            return isSet;
    }

    return false;
}

<#= helperModifier #>int Binomial(int n, int k)
{
    if (k < 0 || k > n)
        return 0;

    if (k == 0 || k == n)
        return 1;

    if (k > n - k)
        k = n - k;

    int result = 1;

    for (int i = 1; i <= k; i++)
        result = checked(result * (n - (k - i)) / i);

    return result;
}