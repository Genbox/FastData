using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.CSharp.Enums;
using Genbox.FastData.Generator.CSharp.Internal.Generators;

namespace Genbox.FastData.Generator.CSharp;

public class CSharpCodeGenerator(CSharpCodeGeneratorConfig userCfg) : ICodeGenerator
{
    private readonly StringBuilder _sb = new StringBuilder();
    private readonly SharedCode _shared = new SharedCode();

    public bool UseUTF16Encoding => true;

    public bool TryGenerate<T>(GeneratorConfig genCfg, IContext context, out string? source)
    {
        _sb.Clear();
        _shared.Clear();

        AppendHeader(genCfg);

        _sb.Append(context switch
        {
            SingleValueContext<T> c2 => new SingleValueCode<T>(genCfg, userCfg, c2).Generate(),
            ArrayContext<T> c1 => new ArrayCode<T>(genCfg, userCfg, c1).Generate(),
            BinarySearchContext<T> c2 => new BinarySearchCode<T>(genCfg, userCfg, c2).Generate(),
            ConditionalContext<T> c2 => new ConditionalCode<T>(genCfg, userCfg, c2).Generate(),
            EytzingerSearchContext<T> c2 => new EytzingerSearchCode<T>(genCfg, userCfg, c2).Generate(),
            PerfectHashBruteForceContext<T> c2 => new PerfectHashBruteForceCode<T>(genCfg, userCfg, c2).Generate(),
            PerfectHashGPerfContext c2 => new PerfectHashGPerfCode(genCfg, userCfg, c2).Generate(),
            HashSetChainContext<T> c2 => new HashSetChainCode<T>(genCfg, userCfg, c2).Generate(),
            HashSetLinearContext<T> c2 => new HashSetLinearCode<T>(genCfg, userCfg, c2).Generate(),
            KeyLengthContext c2 => new KeyLengthCode(genCfg, userCfg, c2).Generate(),
            _ => throw new NotSupportedException("The context type is not supported: " + context.GetType().Name)
        });

        AppendFooter(genCfg);

        // Output any shared classes
        foreach (string cls in _shared.GetType(CodeType.Class))
        {
            _sb.AppendLine()
               .AppendLine(cls);
        }

        source = _sb.ToString();
        return true;
    }

    private void AppendHeader(GeneratorConfig genCfg)
    {
        string cn = userCfg.ClassName;
        string? ns = userCfg.Namespace != null ? $"namespace {userCfg.Namespace};\n" : null;
        string visibility = userCfg.ClassVisibility.ToString().ToLowerInvariant();

        string type = userCfg.ClassType switch
        {
            ClassType.Static => " static class",
            ClassType.Instance => " class",
            ClassType.Struct => " struct",
            _ => throw new InvalidOperationException("Invalid ClassType: " + userCfg.ClassType)
        };

        string? attr = userCfg.ClassType == ClassType.Struct ? "[StructLayout(LayoutKind.Auto)]" : null;
        string? iface = null;

        if (userCfg.ClassType != ClassType.Static && userCfg.GeneratorOptions.HasFlag(CSharpOptions.GenerateInterface))
        {
            iface = $": IFastSet<{genCfg.GetTypeName()}>";

            _shared.Add("IFastSet", CodeType.Class, """
                                                    public interface IFastSet<in T>
                                                    {
                                                        int Length { get; }
                                                        bool Contains(T value);
                                                    }
                                                    """);
        }

        string? partial = userCfg.ClassType != ClassType.Static ? " partial" : null;

        _sb.AppendLine("// <auto-generated />");
        _sb.Append("// Structure: ").AppendLine(genCfg.StructureType.ToString());

#if RELEASE
        _sb.Append("// Generated by: ").AppendLine(genCfg.Metadata.Program);
        _sb.Append("// Generated on: ").AppendLine(genCfg.Metadata.Timestamp);
#endif

        _sb.AppendLine("""
                       #nullable enable
                       using System;
                       using System.Runtime.CompilerServices;
                       using System.Runtime.InteropServices;
                       """);

        if (iface != null)
            _sb.AppendLine("using Genbox.FastData.Generator.CSharp.Abstracts;");

        _sb.AppendLine($$"""

                         {{ns}}
                         {{attr}}{{visibility}}{{partial}}{{type}} {{cn}} {{iface}}
                         {
                         """);
    }

    private void AppendFooter(GeneratorConfig genCfg)
    {
        _sb.Append($"""


                        public const int ItemCount = {genCfg.Constants.ItemCount};
                    """);

        if (userCfg.ClassType is ClassType.Instance or ClassType.Struct && userCfg.GeneratorOptions.HasFlag(CSharpOptions.GenerateInterface))
        {
            _sb.Append("""

                           public int Length => ItemCount;
                       """);
        }
        _sb.AppendLine();

        if (genCfg.DataType.IsInteger())
        {
            _sb.Append("    public const ").Append(genCfg.GetTypeName()).Append(" MinValue = ").Append(ToValueLabel(genCfg.Constants.MinValue, genCfg.DataType)).AppendLine(";");
            _sb.Append("    public const ").Append(genCfg.GetTypeName()).Append(" MaxValue = ").Append(ToValueLabel(genCfg.Constants.MaxValue, genCfg.DataType)).AppendLine(";");
        }
        else if (genCfg.DataType == DataType.String)
        {
            _sb.Append("    public const int MinLength = ").Append(genCfg.Constants.MinValue).AppendLine(";");
            _sb.Append("    public const int MaxLength = ").Append(genCfg.Constants.MaxValue).AppendLine(";");
        }

        _sb.Append('}');
    }
}