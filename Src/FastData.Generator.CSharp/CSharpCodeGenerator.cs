using Genbox.FastData.Generator.CSharp.Enums;
using Genbox.FastData.Generator.CSharp.Internal;
using Genbox.FastData.Generator.CSharp.Internal.Framework;
using Genbox.FastData.Generator.CSharp.Internal.Generators;
using Genbox.FastData.Generator.Framework;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generators;
using Genbox.FastData.Generators.Abstracts;
using Genbox.FastData.Generators.Contexts;

namespace Genbox.FastData.Generator.CSharp;

public sealed class CSharpCodeGenerator : CodeGenerator
{
    private readonly CSharpCodeGeneratorConfig _cfg;

    private CSharpCodeGenerator(CSharpCodeGeneratorConfig cfg, ILanguageDef langDef, IConstantsDef constDef, IEarlyExitDef earlyExitDef, IHashDef hashDef, TypeMap map, ExpressionCompiler compiler)
        : base(langDef, constDef, earlyExitDef, hashDef, map, compiler) => _cfg = cfg;

    public static CSharpCodeGenerator Create(CSharpCodeGeneratorConfig userCfg)
    {
        CSharpLanguageDef langDef = new CSharpLanguageDef();
        TypeMap map = new TypeMap(langDef.TypeDefinitions, langDef.Encoding);

        return new CSharpCodeGenerator(userCfg, langDef, new CSharpConstantsDef(), new CSharpEarlyExitDef(map, userCfg.GeneratorOptions), new CSharpHashDef(), map, new CSharpExpressionCompiler(map));
    }

    protected override void AppendHeader<T>(StringBuilder sb, GeneratorConfig<T> genCfg, IContext context)
    {
        sb.AppendLine("// <auto-generated />");
        base.AppendHeader(sb, genCfg, context);

        sb.Append("""
                  #nullable enable
                  using System;
                  using System.Runtime.CompilerServices;
                  using System.Runtime.InteropServices;

                  """);

        string cn = _cfg.ClassName;
        string? ns = _cfg.Namespace != null ? $"namespace {_cfg.Namespace};\n\n" : null;
        string visibility = _cfg.ClassVisibility.ToString().ToLowerInvariant();

        string type = _cfg.ClassType switch
        {
            ClassType.Static => " static class",
            ClassType.Instance => " class",
            ClassType.Struct => " struct",
            _ => throw new InvalidOperationException("Invalid ClassType: " + _cfg.ClassType)
        };

        string? attr = _cfg.ClassType == ClassType.Struct ? "[StructLayout(LayoutKind.Auto)]\n" : null;
        string? partial = _cfg.ClassType != ClassType.Static ? " partial" : null;

        sb.AppendLine($$"""

                        {{ns}}{{attr}}{{visibility}}{{partial}}{{type}} {{cn}}
                        {
                        """);
    }

    protected override void AppendFooter<T>(StringBuilder sb, GeneratorConfig<T> genCfg, string typeName)
    {
        base.AppendFooter(sb, genCfg, typeName);

        sb.Append('}');
    }

    protected override OutputWriter<TKey>? GetOutputWriter<TKey, TValue>(GeneratorConfig<TKey> genCfg, IContext context) => context switch
    {
        SingleValueContext<TKey, TValue> x => new SingleValueCode<TKey, TValue>(x, _cfg),
        ArrayContext<TKey, TValue> x => new ArrayCode<TKey, TValue>(x, _cfg),
        BinarySearchContext<TKey, TValue> x => new BinarySearchCode<TKey, TValue>(x, _cfg),
        ConditionalContext<TKey, TValue> x => new ConditionalCode<TKey, TValue>(x, _cfg),
        EytzingerSearchContext<TKey, TValue> x => new EytzingerSearchCode<TKey, TValue>(x, _cfg),
        HashTableChainContext<TKey, TValue> x => new HashTableChainCode<TKey, TValue>(x, _cfg),
        HashTablePerfectContext<TKey, TValue> x => new HashTablePerfectCode<TKey, TValue>(x, _cfg),
        KeyLengthContext<TValue> x => new KeyLengthCode<TKey, TValue>(x, _cfg),
        _ => null
    };
}