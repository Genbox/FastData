using Genbox.FastData.Generator.CSharp.Enums;
using Genbox.FastData.Generator.CSharp.Internal.Framework;
using Genbox.FastData.Generator.CSharp.Internal.Generators;
using Genbox.FastData.Generator.Framework;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generator.Framework.Interfaces.Specs;

namespace Genbox.FastData.Generator.CSharp;

public sealed class CSharpCodeGenerator : CodeGenerator
{
    private readonly CSharpCodeGeneratorConfig _userCfg;

    private CSharpCodeGenerator(CSharpCodeGeneratorConfig userCfg,
                                ILanguageSpec langSpec,
                                ICodeSpec codeSpec,
                                IConstantsSpec constants,
                                IEarlyExitHandler earlyExitHandler,
                                IHashHandler hashHandler) : base(langSpec, codeSpec, constants, earlyExitHandler, hashHandler)
    {
        _userCfg = userCfg;
    }

    public static CSharpCodeGenerator Create(CSharpCodeGeneratorConfig userCfg)
    {
        CSharpLanguageSpec langSpec = new CSharpLanguageSpec();
        TypeMap typeMap = new TypeMap(langSpec.Primitives);
        CodeHelper helper = new CodeHelper(langSpec, typeMap);

        return new CSharpCodeGenerator(userCfg, langSpec, new CSharpCodeSpec(userCfg), new CSharpConstantsSpec(), new CSharpEarlyExitHandler(helper, userCfg.GeneratorOptions),
            new CSharpHashHandler());
    }

    protected override void AppendHeader<T>(StringBuilder sb, GeneratorConfig<T> genCfg)
    {
        sb.AppendLine("// <auto-generated />");
        base.AppendHeader(sb, genCfg);

        sb.Append("""
                  #nullable enable
                  using System;
                  using System.Runtime.CompilerServices;
                  using System.Runtime.InteropServices;

                  """);

        string cn = _userCfg.ClassName;
        string? ns = _userCfg.Namespace != null ? $"namespace {_userCfg.Namespace};\n" : null;
        string visibility = _userCfg.ClassVisibility.ToString().ToLowerInvariant();

        string type = _userCfg.ClassType switch
        {
            ClassType.Static => " static class",
            ClassType.Instance => " class",
            ClassType.Struct => " struct",
            _ => throw new InvalidOperationException("Invalid ClassType: " + _userCfg.ClassType)
        };

        string? attr = _userCfg.ClassType == ClassType.Struct ? "[StructLayout(LayoutKind.Auto)]" : null;
        string? partial = _userCfg.ClassType != ClassType.Static ? " partial" : null;

        sb.AppendLine($$"""

                        {{ns}}
                        {{attr}}{{visibility}}{{partial}}{{type}} {{cn}}
                        {
                        """);
    }

    protected override void AppendFooter<T>(StringBuilder sb, GeneratorConfig<T> genCfg, string typeName)
    {
        base.AppendFooter(sb, genCfg, typeName);

        sb.Append('}');
    }

    protected override OutputWriter<T>? GetOutputWriter<T>(GeneratorConfig<T> genCfg, IContext context) => context switch
    {
        SingleValueContext<T> x => new SingleValueCode<T>(x),
        ArrayContext<T> x => new ArrayCode<T>(x),
        BinarySearchContext<T> x => new BinarySearchCode<T>(x),
        ConditionalContext<T> x => new ConditionalCode<T>(x, _userCfg),
        EytzingerSearchContext<T> x => new EytzingerSearchCode<T>(x),
        PerfectHashBruteForceContext<T> x => new PerfectHashBruteForceCode<T>(x),
        PerfectHashGPerfContext x => new PerfectHashGPerfCode<T>(x, genCfg, _userCfg),
        HashSetChainContext<T> x => new HashSetChainCode<T>(x),
        HashSetLinearContext<T> x => new HashSetLinearCode<T>(x),
        KeyLengthContext x => new KeyLengthCode<T>(x, _userCfg),
        _ => null
    };
}