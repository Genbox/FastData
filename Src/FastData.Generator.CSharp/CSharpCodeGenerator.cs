using Genbox.FastData.Generator.CSharp.Enums;
using Genbox.FastData.Generator.CSharp.Internal;
using Genbox.FastData.Generator.CSharp.Internal.Framework;
using Genbox.FastData.Generator.CSharp.TemplateData;
using Genbox.FastData.Generator.Enums;
using Genbox.FastData.Generator.Extensions;
using Genbox.FastData.Generator.Framework;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generators;
using Genbox.FastData.Generators.Abstracts;
using Genbox.FastData.Generators.Contexts;
using Genbox.FastData.Generators.Helpers;
using Genbox.FastData.Generator.Template.Abstracts;
using Genbox.FastData.Generator.Template.Extensions;
using Genbox.FastData.Generator.Template.Helpers;

namespace Genbox.FastData.Generator.CSharp;

public sealed class CSharpCodeGenerator : CodeGenerator
{
    private readonly CSharpCodeGeneratorConfig _cfg;

    private CSharpCodeGenerator(CSharpCodeGeneratorConfig cfg, ILanguageDef langDef, IConstantsDef constDef, IEarlyExitDef earlyExitDef, IHashDef hashDef, TypeMap map, ExpressionCompiler compiler)
        : base(langDef, constDef, earlyExitDef, hashDef, map, compiler) => _cfg = cfg;

    public static CSharpCodeGenerator Create(CSharpCodeGeneratorConfig userCfg)
    {
        CSharpLanguageDef langDef = new CSharpLanguageDef();
        TypeMap map = new TypeMap(langDef.TypeDefinitions, GeneratorEncoding.UTF16);

        return new CSharpCodeGenerator(userCfg, langDef, new CSharpConstantsDef(), new CSharpEarlyExitDef(map, userCfg.GeneratorOptions), new CSharpHashDef(), map, new CSharpExpressionCompiler(map));
    }

    public override GeneratorEncoding Encoding => GeneratorEncoding.UTF16;

    protected override void AppendHeader<TKey, TValue>(StringBuilder sb, GeneratorConfigBase genCfg, IContext context)
    {
        sb.AppendLine("// <auto-generated />");
        base.AppendHeader<TKey, TValue>(sb, genCfg, context);

        sb.Append("""
                  #nullable enable
                  using System;
                  using System.Runtime.CompilerServices;
                  using System.Runtime.InteropServices;

                  """);
    }

    protected override void AppendBody<TKey, TValue>(StringBuilder sb, GeneratorConfigBase genCfg, string keyTypeName, string valueTypeName, IContext context)
    {
        string cn = _cfg.ClassName;
        string? ns = _cfg.Namespace != null ? $"namespace {_cfg.Namespace};\n\n" : null;
        string visibility = _cfg.ClassVisibility.ToString().ToLowerInvariant();

        string type = _cfg.ClassType switch
        {
            ClassType.Static => " static class",
            ClassType.Instance => " class",
            ClassType.Struct => " struct",
            _ => throw new InvalidOperationException("Invalid ClassType: " + _cfg.ClassType)
        };

        string? attr = _cfg.ClassType == ClassType.Struct ? "[StructLayout(LayoutKind.Auto)]\n" : null;
        string? partial = _cfg.ClassType != ClassType.Static ? " partial" : null;

        sb.AppendLine($$"""

                        {{ns}}{{attr}}{{visibility}}{{partial}}{{type}} {{cn}}
                        {
                        """);

        base.AppendBody<TKey, TValue>(sb, genCfg, keyTypeName, valueTypeName, context);
    }

    protected override void AppendFooter<T>(StringBuilder sb, GeneratorConfigBase genCfg, string typeName)
    {
        base.AppendFooter<T>(sb, genCfg, typeName);

        sb.Append('}');
    }

    protected override OutputWriter<TKey> GetOutputWriter<TKey, TValue>(GeneratorConfigBase genCfg, IContext context) => new TemplateBasedOutputWriter<TKey, TValue>(context, _cfg);

    private sealed class TemplateBasedOutputWriter<TKey, TValue>(IContext context, CSharpCodeGeneratorConfig cfg) : OutputWriter<TKey>
    {
        public override string Generate()
        {
            string raw = context.GetType().Name;
            int idx = raw.IndexOf("Context", StringComparison.Ordinal);
            string name = raw.Substring(0, idx) + "Code.t4";
            string source = File.ReadAllText(Path.Combine(AppContext.BaseDirectory, "Templates", "CSharp", name));

            return TemplateHelper.Render(this, name, source, new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase)
            {
                {
                    "Model", new TemplateModel
                    {
                        HashSource = HashSource,
                        FieldModifier = cfg.ClassType == ClassType.Static ? "private static readonly " : "private readonly ",
                        MethodModifier = cfg.ClassType == ClassType.Static ? "public static " : "public ",
                        MethodAttribute = GetMethodAttribute(),
                        KeyTypeName = KeyTypeName,
                        KeyTypeCode = Type.GetTypeCode(typeof(TKey)),
                        ValueTypeName = ValueTypeName,
                        GetMethodHeader = GetMethodHeader,
                        GetEqualFunction = (a, b) => GetEqualFunction(a, b),
                        GetEqualFunctionByType = GetEqualFunction,
                        GetCompareFunction = GetCompareFunction,
                        GetModFunction = GetModFunction,
                        GetSmallestSignedType = GetSmallestSignedType,
                        GetSmallestUnsignedType = GetSmallestUnsignedType,
                        ToValueLabel = ToValueLabel,
                        ValueObjectDeclarations = GetObjectDeclarations<TValue>()
                    }
                },
                { "Context", context },
                { "Cfg", cfg },
                { "Shared", Shared },
                { "Data", CreateContextModel() }
            });
        }

        private ITemplateData? CreateContextModel()
        {
            switch (context)
            {
                case ArrayContext<TKey, TValue> arrayCtx:
                    return new ArrayTemplateData
                    {
                        Keys = arrayCtx.Keys.ToObjects(),
                        KeyCount = arrayCtx.Keys.Length,
                        Values = arrayCtx.Values.ToObjects(),
                        ValueCount = arrayCtx.Values.Length
                    };

                case BinarySearchContext<TKey, TValue> bsCtx:
                    return new BinarySearchTemplateData
                    {
                        Keys = bsCtx.Keys.ToObjects(),
                        KeyCount = bsCtx.Keys.Length,
                        Values = bsCtx.Values.ToObjects(),
                        ValueCount = bsCtx.Values.Length
                    };

                case InterpolatedBinarySearchContext<TKey, TValue> ibsCtx:
                    return new BinarySearchTemplateData
                    {
                        Keys = ibsCtx.Keys.ToObjects(),
                        KeyCount = ibsCtx.Keys.Length,
                        Values = ibsCtx.Values.ToObjects(),
                        ValueCount = ibsCtx.Values.Length
                    };

                case ConditionalContext<TKey, TValue> conCtx:
                    return new ArrayTemplateData
                    {
                        Keys = conCtx.Keys.ToObjects(),
                        KeyCount = conCtx.Keys.Length,
                        Values = conCtx.Values.ToObjects(),
                        ValueCount = conCtx.Values.Length
                    };

                case SingleValueContext<TKey, TValue> singleCtx:
                    return new SingleValueTemplateData
                    {
                        Item = singleCtx.Key,
                        Value = singleCtx.Values.IsEmpty ? null : singleCtx.Values.Span[0]
                    };

                case RangeContext<TKey> rangeCtx:
                    return new RangeTemplateData
                    {
                        Min = rangeCtx.Min,
                        Max = rangeCtx.Max
                    };

                case KeyLengthContext<TValue> klCtx:
                    return new KeyLengthTemplateData
                    {
                        Keys = klCtx.Lengths,
                        KeyCount = klCtx.Lengths.Length,
                        Values = klCtx.Values.ToObjects(),
                        ValueCount = klCtx.Values.Length
                    };

                case BloomFilterContext:
                    return null;

                case BitSetContext<TValue> bsCtx:
                    return new BitSetTemplateData
                    {
                        Values = bsCtx.Values.ToObjects(),
                        ValueCount = bsCtx.Values.Length
                    };

                case HashTableContext<TKey, TValue> hashCtx:
                    HashTableEntryTemplateData[] hashEntries = new HashTableEntryTemplateData[hashCtx.Entries.Length];

                    for (int i = 0; i < hashCtx.Entries.Length; i++)
                    {
                        hashEntries[i] = new HashTableEntryTemplateData
                        {
                            Key = hashCtx.Entries[i].Key,
                            Hash = hashCtx.Entries[i].Hash,
                            Next = hashCtx.Entries[i].Next
                        };
                    }

                    return new HashTableTemplateData
                    {
                        Entries = hashEntries,
                        Values = hashCtx.Values.ToObjects(),
                        ValueCount = hashCtx.Values.Length
                    };

                case HashTableCompactContext<TKey, TValue> compactCtx:
                    HashTableCompactEntryTemplateData[] compactEntries = new HashTableCompactEntryTemplateData[compactCtx.Entries.Length];

                    for (int i = 0; i < compactCtx.Entries.Length; i++)
                    {
                        compactEntries[i] = new HashTableCompactEntryTemplateData
                        {
                            Key = compactCtx.Entries[i].Key,
                            Hash = compactCtx.Entries[i].Hash
                        };
                    }

                    return new HashTableCompactTemplateData
                    {
                        Entries = compactEntries,
                        Values = compactCtx.Values.ToObjects(),
                        ValueCount = compactCtx.Values.Length
                    };

                case HashTablePerfectContext<TKey, TValue> perfectCtx:
                    HashTablePerfectEntryTemplateData[] perfectEntries = new HashTablePerfectEntryTemplateData[perfectCtx.Data.Length];

                    for (int i = 0; i < perfectCtx.Data.Length; i++)
                    {
                        perfectEntries[i] = new HashTablePerfectEntryTemplateData
                        {
                            Key = perfectCtx.Data[i].Key,
                            Hash = perfectCtx.Data[i].Value
                        };
                    }

                    return new HashTablePerfectTemplateData
                    {
                        Entries = perfectEntries,
                        Values = perfectCtx.Values.ToObjects(),
                        ValueCount = perfectCtx.Values.Length
                    };

                case RrrBitVectorContext:
                    return null;

                case EliasFanoContext<TKey>:
                    //TODO
                    return null;

                default:
                    throw new InvalidOperationException("No template mapping found for context type: " + context.GetType().FullName);
            }
        }

        private string GetMethodAttribute()
        {
            if (cfg.GeneratorOptions.HasFlag(CSharpOptions.DisableInlining))
                return "[MethodImpl(MethodImplOptions.NoInlining)]";

            if (cfg.GeneratorOptions.HasFlag(CSharpOptions.AggressiveInlining))
                return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";

            return string.Empty;
        }

        private string GetCompareFunction(string var1, string var2)
        {
            if (GeneratorConfig is StringGeneratorConfig strCfg)
                return $"StringComparer.{StringHelper.GetStringComparer(strCfg.IgnoreCase)}.Compare({var1}, {var2})";

            return $"{var1}.CompareTo({var2})";
        }

        protected override string GetEqualFunctionInternal(string var1, string var2, TypeCode overrideType)
        {
            if (overrideType == TypeCode.String && GeneratorConfig is StringGeneratorConfig strCfg)
                return $"StringComparer.{StringHelper.GetStringComparer(strCfg.IgnoreCase)}.Equals({var1}, {var2})";

            return $"{var1} == {var2}";
        }

        protected override string GetMethodHeader(MethodType methodType)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(base.GetMethodHeader(methodType));

            if (GeneratorConfig is StringGeneratorConfig strCfg && strCfg.TotalTrimLength != 0)
                sb.Append($"    string {TrimmedKeyName} = {InputKeyName}.Substring({strCfg.TrimPrefix.Length.ToStringInvariant()}, {InputKeyName}.Length - {strCfg.TotalTrimLength.ToStringInvariant()});");

            return sb.ToString();
        }

        protected override string GetModFunction(string variable, ulong value)
        {
            if (value == 0)
                throw new ArgumentOutOfRangeException(nameof(value), "A length of 0 is not valid in a modulus operation");

            if (value == 1)
                return "0";

            if (MathHelper.IsPowerOfTwo((uint)value) && !cfg.GeneratorOptions.HasFlag(CSharpOptions.DisableModulusOptimization))
                return $"({ArraySizeType})({variable} & {value - 1})";

            return $"({ArraySizeType})({variable} % {value})";
        }
    }
}