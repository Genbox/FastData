using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.Rust.Internal.Generators;

namespace Genbox.FastData.Generator.Rust;

public class RustCodeGenerator(RustGeneratorConfig userCfg) : IGenerator
{
    private readonly StringBuilder _sb = new StringBuilder();
    private readonly SharedCode _shared = new SharedCode();

    public bool TryGenerate(GeneratorConfig genCfg, IContext context, out string? source)
    {
        _sb.Clear();
        _shared.Clear();

        AppendHeader(genCfg);

        _sb.Append(context switch
        {
            SingleValueContext c2 => new SingleValueCode(genCfg, userCfg, c2).Generate(),
            ArrayContext c1 => new ArrayCode(genCfg, userCfg, c1).Generate(),
            BinarySearchContext c2 => new BinarySearchCode(genCfg, userCfg, c2).Generate(),
            ConditionalContext c2 => new ConditionalCode(genCfg, userCfg, c2).Generate(),
            EytzingerSearchContext c2 => new EytzingerSearchCode(genCfg, userCfg, c2).Generate(),
            PerfectHashBruteForceContext c2 => new PerfectHashBruteForceCode(genCfg, userCfg, c2, _shared).Generate(),
            PerfectHashGPerfContext c2 => new PerfectHashGPerfCode(genCfg, userCfg, c2).Generate(),
            HashSetChainContext c2 => new HashSetChainCode(genCfg, userCfg, c2, _shared).Generate(),
            HashSetLinearContext c2 => new HashSetLinearCode(genCfg, userCfg, c2, _shared).Generate(),
            KeyLengthContext c2 => new KeyLengthCode(genCfg, userCfg, c2).Generate(),
            _ => throw new NotSupportedException("The context type is not supported: " + context.GetType().Name)
        });

        AppendFooter(genCfg);

        // Output any shared classes
        foreach (string cls in _shared.GetType(CodeType.Class))
        {
            _sb.AppendLine()
               .AppendLine(cls);
        }

        source = _sb.ToString();
        return true;
    }

    private void AppendHeader(GeneratorConfig genCfg)
    {
        _sb.AppendLine("//! This file is auto-generated. Do not edit manually.");
        _sb.Append("//! Structure: ").AppendLine(genCfg.StructureType.ToString());

#if RELEASE
        _sb.Append("//! Generated by: ").AppendLine(genCfg.Metadata.Program);
        _sb.Append("//! Generated on: ").AppendLine(genCfg.Metadata.Timestamp);
#endif

        _sb.Append($$"""
                     #![allow(unused_parens)]
                     #![allow(missing_docs)]
                     #![allow(unused_imports)]
                     #![allow(unused_unsafe)]
                     use std::ptr;

                     pub struct {{userCfg.ClassName}};

                     impl {{userCfg.ClassName}} {

                     """);
    }

    private void AppendFooter(GeneratorConfig genCfg)
    {
        _sb.Append($"""


                        pub const ITEM_COUNT: usize = {genCfg.Constants.ItemCount};
                    """);

        _sb.AppendLine();

        if (genCfg.DataType.IsInteger())
        {
            _sb.Append("    pub const MIN_VALUE: ").Append(genCfg.GetTypeName()).Append(" = ").Append(ToValueLabel(genCfg.Constants.MinValue, genCfg.DataType)).AppendLine(";");
            _sb.Append("    pub const MAX_VALUE: ").Append(genCfg.GetTypeName()).Append(" = ").Append(ToValueLabel(genCfg.Constants.MaxValue, genCfg.DataType)).AppendLine(";");
        }
        else if (genCfg.DataType == DataType.String)
        {
            _sb.Append("    pub const MIN_LENGTH: usize = ").Append(genCfg.Constants.MinValue).AppendLine(";");
            _sb.Append("    pub const MAX_LENGTH: usize = ").Append(genCfg.Constants.MaxValue).AppendLine(";");
        }

        _sb.Append('}');
    }
}