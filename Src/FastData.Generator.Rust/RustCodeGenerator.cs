using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.Enums;
using Genbox.FastData.Generator.Rust.Internal.Generators;

namespace Genbox.FastData.Generator.Rust;

public class RustCodeGenerator(RustCodeGeneratorConfig userCfg) : ICodeGenerator
{
    private readonly StringBuilder _sb = new StringBuilder();
    private readonly SharedCode _shared = new SharedCode();

    public bool UseUTF16Encoding => false;

    public bool TryGenerate<T>(GeneratorConfig<T> genCfg, IContext context, out string? source)
    {
        _sb.Clear();
        _shared.Clear();

        AppendHeader(genCfg);

        _sb.Append(context switch
        {
            SingleValueContext<T> c2 => new SingleValueCode<T>(genCfg, userCfg, c2).Generate(),
            ArrayContext<T> c1 => new ArrayCode<T>(genCfg, userCfg, c1).Generate(),
            BinarySearchContext<T> c2 => new BinarySearchCode<T>(genCfg, userCfg, c2).Generate(),
            ConditionalContext<T> c2 => new ConditionalCode<T>(genCfg, userCfg, c2).Generate(),
            EytzingerSearchContext<T> c2 => new EytzingerSearchCode<T>(genCfg, userCfg, c2).Generate(),
            PerfectHashBruteForceContext<T> c2 => new PerfectHashBruteForceCode<T>(genCfg, userCfg, c2, _shared).Generate(),
            PerfectHashGPerfContext c2 => new PerfectHashGPerfCode<T>(genCfg, userCfg, c2).Generate(),
            HashSetChainContext<T> c2 => new HashSetChainCode<T>(genCfg, userCfg, c2, _shared).Generate(),
            HashSetLinearContext<T> c2 => new HashSetLinearCode<T>(genCfg, userCfg, c2, _shared).Generate(),
            KeyLengthContext c2 => new KeyLengthCode<T>(genCfg, userCfg, c2).Generate(),
            _ => throw new NotSupportedException("The context type is not supported: " + context.GetType().Name)
        });

        AppendFooter(genCfg);

        // Output any shared classes
        foreach (string cls in _shared.GetType(CodeType.Class))
        {
            _sb.AppendLine()
               .AppendLine(cls);
        }

        source = _sb.ToString();
        return true;
    }

    private void AppendHeader<T>(GeneratorConfig<T> genCfg)
    {
        _sb.AppendLine("//! This file is auto-generated. Do not edit manually.");
        _sb.Append("//! Structure: ").AppendLine(genCfg.StructureType.ToString());

#if RELEASE
        _sb.Append("//! Generated by: ").AppendLine(genCfg.Metadata.Program);
        _sb.Append("//! Generated on: ").AppendLine(genCfg.Metadata.Timestamp);
#endif

        _sb.Append($$"""
                     #![allow(unused_parens)]
                     #![allow(missing_docs)]
                     #![allow(unused_imports)]
                     #![allow(unused_unsafe)]
                     use std::ptr;

                     pub struct {{userCfg.ClassName}};

                     impl {{userCfg.ClassName}} {

                     """);
    }

    private void AppendFooter<T>(GeneratorConfig<T> genCfg)
    {
        _sb.Append($"""


                        pub const ITEM_COUNT: usize = {genCfg.Constants.ItemCount};
                    """);

        _sb.AppendLine();

        if (genCfg.DataType.IsInteger())
        {
            _sb.Append("    pub const MIN_VALUE: ").Append(genCfg.GetTypeName()).Append(" = ").Append(ToValueLabel(genCfg.Constants.MinValue, genCfg.DataType)).AppendLine(";");
            _sb.Append("    pub const MAX_VALUE: ").Append(genCfg.GetTypeName()).Append(" = ").Append(ToValueLabel(genCfg.Constants.MaxValue, genCfg.DataType)).AppendLine(";");
        }
        else if (genCfg.DataType == DataType.String)
        {
            _sb.Append("    pub const MIN_LENGTH: usize = ").Append(genCfg.Constants.MinStringLength).AppendLine(";");
            _sb.Append("    pub const MAX_LENGTH: usize = ").Append(genCfg.Constants.MaxStringLength).AppendLine(";");
        }

        _sb.Append('}');
    }
}