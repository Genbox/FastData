<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>
<#@ import namespace="System" #>
<#@ import namespace="Genbox.FastData.Generator.Extensions" #>

<#@ parameter type="Genbox.FastData.Generator.Rust.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.RrrBitVectorContext" name="Context" #>

<#
    string mapSource = Model.KeyType switch
    {
        KeyType.Char => $"{Common.LookupKeyName} as u64",
        KeyType.Byte => $"{Common.LookupKeyName} as u64",
        KeyType.UInt16 => $"{Common.LookupKeyName} as u64",
        KeyType.UInt32 => $"{Common.LookupKeyName} as u64",
        KeyType.UInt64 => Common.LookupKeyName,
        KeyType.SByte => $"({Common.LookupKeyName} ^ i8::MIN) as u8 as u64",
        KeyType.Int16 => $"({Common.LookupKeyName} ^ i16::MIN) as u16 as u64",
        KeyType.Int32 => $"({Common.LookupKeyName} ^ i32::MIN) as u32 as u64",
        KeyType.Int64 => $"({Common.LookupKeyName} ^ i64::MIN) as u64",
        _ => throw new InvalidOperationException("RRR bitvector only supports integral key types.")
        };
#>
const RRR_MIN_VALUE: u64 = <#= Model.ToValueLabel(Context.MinValue) #>;
const RRR_MAX_VALUE: u64 = <#= Model.ToValueLabel(Context.MaxValue) #>;
const RRR_BLOCK_SIZE: i32 = <#= Context.BlockSize #>;
<#= Model.FieldModifier #>RRR_CLASSES: [u8; <#= Context.Classes.Length.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Context.Classes, x => Model.ToValueLabel(x)) #>
];
<#= Model.FieldModifier #>RRR_OFFSETS: [u32; <#= Context.Offsets.Length.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Context.Offsets, x => Model.ToValueLabel(x)) #>
];

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>fn contains(<#= Common.InputKeyName #>: <#= Model.GetKeyTypeName() #>) -> bool {
<#= Model.GetMethodHeader(MethodType.Contains) #>

    let mapped = <#= mapSource #>;

    if mapped < Self::RRR_MIN_VALUE || mapped > Self::RRR_MAX_VALUE {
        return false;
    }

    let normalized = mapped - Self::RRR_MIN_VALUE;
    let block_index = (normalized / (Self::RRR_BLOCK_SIZE as u64)) as usize;
    let bit_in_block = (normalized % (Self::RRR_BLOCK_SIZE as u64)) as i32;
    let class_value = Self::RRR_CLASSES[block_index] as i32;

    if class_value == 0 {
        return false;
    }

    let rank = Self::RRR_OFFSETS[block_index];
    Self::decode_bit(class_value, rank, bit_in_block)
}

fn decode_bit(class_value: i32, mut rank: u32, target_bit: i32) -> bool {
    let mut remaining = class_value;

    for bit in (0..(Self::RRR_BLOCK_SIZE as usize)).rev() {
        if remaining == 0 {
            return false;
        }

        let bit = bit as i32;
        let comb = Self::binomial(bit, remaining);
        let is_set;

        if rank >= comb as u32 {
            rank -= comb as u32;
            remaining -= 1;
            is_set = true;
        } else {
            is_set = false;
        }

        if bit == target_bit {
            return is_set;
        }
    }

    false
}

fn binomial(n: i32, mut k: i32) -> i32 {
    if k < 0 || k > n {
        return 0;
    }

    if k == 0 || k == n {
        return 1;
    }

    if k > n - k {
        k = n - k;
    }

    let mut result = 1i32;
    let mut i = 1i32;

    while i <= k {
        result = result * (n - (k - i)) / i;
        i += 1;
    }

    result
}
