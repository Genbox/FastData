<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Extensions" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>

<#@ parameter type="Genbox.FastData.Generator.Rust.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.SharedCode" name="Shared" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.HashTableCompactContext" name="Context" #>
<#@ parameter type="Genbox.FastData.Generator.Rust.TemplateData.HashTableCompactTemplateData" name="Data" #>

<#
    string[] valueLabels = Data.Values.Select(Model.ToValueLabel).ToArray();
    StringBuilder structBuilder = new StringBuilder();
    structBuilder.AppendLine("struct E {");
    if (Context.StoreHashCode)
        structBuilder.AppendLine($"    hash_code: {Common.HashSizeType},");
    structBuilder.AppendLine($"    key: {Model.GetKeyTypeName(!Model.IsPrimitive)},");
    if (Data.ValueCount > 0)
        structBuilder.AppendLine($"    value: {Model.GetValueTypeName(!Model.IsPrimitive)},");
    structBuilder.AppendLine("}");
    Shared.Add(CodePlacement.After, structBuilder.ToString());
#>
<#= Model.FieldModifier #>BUCKET_STARTS: [<#= Model.GetSmallestUnsignedType(Data.Entries.Length) #>; <#= Context.BucketStarts.Length.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Context.BucketStarts, (_, x) => x.ToStringInvariant()) #>
    ];

<#= Model.FieldModifier #>BUCKET_COUNTS: [<#= Model.GetSmallestUnsignedType(Data.Entries.Length) #>; <#= Context.BucketCounts.Length.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Context.BucketCounts, (_, x) => x.ToStringInvariant()) #>
    ];

<#= Model.FieldModifier #>ENTRIES: [E; <#= Data.Entries.Length.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Data.Entries, (i, x) =>
    {
        string hashPart = Context.StoreHashCode ? $"hash_code: {x.Hash}, " : "";
        string valuePart = Data.ValueCount > 0 ? $", value: {valueLabels[i]}" : "";
        return $"E {{ {hashPart}key: {Model.ToValueLabel(x.Key)}{valuePart} }}";
    }) #>
    ];

<#= Model.HashSource #>

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>fn contains(<#= Common.InputKeyName #>: <#= Model.GetKeyTypeName(!Model.IsPrimitive) #>) -> bool {
<#= Model.GetMethodHeader(MethodType.Contains) #>

    let hash = unsafe { Self::get_hash(<#= Common.LookupKeyName #>) };
    let index = <#= Model.GetModFunction("hash", (ulong)Context.BucketStarts.Length) #>;
    let start = Self::BUCKET_STARTS[index as usize] as usize;
    let count = Self::BUCKET_COUNTS[index as usize] as usize;
    let end = start + count;

    for i in start..end {
        let entry = &Self::ENTRIES[i];
        if <#
    if (Context.StoreHashCode)
    {
#><#= Model.GetEqualFunctionByType("entry.hash_code", "hash", KeyType.Int64) #> && <#
    }
#><#= Model.GetEqualFunction("entry.key", Common.LookupKeyName) #> {
            return true;
        }
    }

    false
}
<#
    if (Data.ValueCount > 0)
    {
        Shared.Add(CodePlacement.Before, Model.ValueObjectDeclarations);
#>

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>fn try_lookup(<#= Common.InputKeyName #>: <#= Model.GetKeyTypeName(!Model.IsPrimitive) #>) -> Option<<#= Model.GetValueTypeName(!Model.IsPrimitive) #>> {
<#= Model.GetMethodHeader(MethodType.TryLookup) #>

    let hash = unsafe { Self::get_hash(<#= Common.LookupKeyName #>) };
    let index = <#= Model.GetModFunction("hash", (ulong)Context.BucketStarts.Length) #>;
    let start = Self::BUCKET_STARTS[index as usize] as usize;
    let count = Self::BUCKET_COUNTS[index as usize] as usize;
    let end = start + count;

    for i in start..end {
        let entry = &Self::ENTRIES[i];
        if <#
    if (Context.StoreHashCode)
    {
#><#= Model.GetEqualFunctionByType("entry.hash_code", "hash", KeyType.Int64) #> && <#
    }
#><#= Model.GetEqualFunction("entry.key", Common.LookupKeyName) #> {
            return Some(entry.value);
        }
    }

    None
}
<#
    }
#>
