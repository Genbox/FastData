<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Extensions" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>

<#@ parameter type="Genbox.FastData.Generator.Rust.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.SharedCode" name="Shared" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generator.Rust.TemplateData.BinarySearchTemplateData" name="Data" #>

<#
    if (Data.ValueCount > 0)
    {
        Shared.Add(CodePlacement.Before, Model.ValueObjectDeclarations);
#>
<#= Model.FieldModifier #>VALUES: [<#= Model.GetValueTypeName() #>; <#= Data.ValueCount.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Data.Values, Data.ValueCount, Model.ToValueLabel) #>
];

<#
    }
#>
<#= Model.FieldModifier #>KEYS: [<#= Model.GetKeyTypeName() #>; <#= Data.KeyCount.ToStringInvariant() #>] = [
<#= FormatHelper.FormatColumns(Data.Keys, Data.KeyCount, Model.ToValueLabel) #>
];

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>fn contains(<#= Common.InputKeyName #>: <#= Model.GetKeyTypeName() #>) -> bool {
<#= Model.GetMethodHeader(MethodType.Contains) #>

    let mut lo: usize = 0;
    let mut hi: usize = <#= (Data.KeyCount - 1).ToStringInvariant() #>;
    while lo <= hi && <#= Common.LookupKeyName #> >= Self::KEYS[lo] && <#= Common.LookupKeyName #> <= Self::KEYS[hi] {
        let lo_key = Self::KEYS[lo];
        let hi_key = Self::KEYS[hi];

        if lo_key == hi_key {
            if lo_key == <#= Common.LookupKeyName #> {
                return true;
            }

            break;
        }

        let range = (hi_key as f64) - (lo_key as f64);
        let offset = (<#= Common.LookupKeyName #> as f64) - (lo_key as f64);
        let mut i = lo + ((offset * (hi - lo) as f64) / range) as usize;

        if i < lo {
            i = lo;
        } else if i > hi {
            i = hi;
        }

        let entry = Self::KEYS[i];
        if entry == <#= Common.LookupKeyName #> {
            return true;
        }
        if entry < <#= Common.LookupKeyName #> {
            lo = i + 1;
        } else {
            hi = i - 1;
        }
    }

    false
}
<#
    if (Data.ValueCount > 0)
    {
#>

<#= Model.MethodAttribute #>
<#= Model.MethodModifier #>fn try_lookup(<#= Common.InputKeyName #>: <#= Model.GetKeyTypeName() #>) -> Option<<#= Model.GetValueTypeName() #>> {
<#= Model.GetMethodHeader(MethodType.TryLookup) #>

    let mut lo: usize = 0;
    let mut hi: usize = <#= (Data.KeyCount - 1).ToStringInvariant() #>;
    while lo <= hi && <#= Common.LookupKeyName #> >= Self::KEYS[lo] && <#= Common.LookupKeyName #> <= Self::KEYS[hi] {
        let lo_key = Self::KEYS[lo];
        let hi_key = Self::KEYS[hi];

        if lo_key == hi_key {
            if lo_key == <#= Common.LookupKeyName #> {
                return Some(Self::VALUES[lo]);
            }

            break;
        }

        let range = (hi_key as f64) - (lo_key as f64);
        let offset = (<#= Common.LookupKeyName #> as f64) - (lo_key as f64);
        let mut i = lo + ((offset * (hi - lo) as f64) / range) as usize;

        if i < lo {
            i = lo;
        } else if i > hi {
            i = hi;
        }

        let entry = Self::KEYS[i];
        if entry == <#= Common.LookupKeyName #> {
            return Some(Self::VALUES[i]);
        }
        if entry < <#= Common.LookupKeyName #> {
            lo = i + 1;
        } else {
            hi = i - 1;
        }
    }

    None
}
<#
    }
#>
