// <auto-generated />
// Structure: HashSetLinear
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Genbox.FastData.Helpers;
using Genbox.FastData.Generator.CSharp.Abstracts;


internal partial class MyData : IFastSet<String>
{
    private readonly B[] _buckets = {
        new B(0, 0), new B(0, 0), new B(0, 0), new B(1, 1), new B(0, 0), new B(2, 2), new B(3, 3), new B(4, 4), new B(0, 0), new B(0, 0), 
        new B(5, 5), new B(0, 0), new B(0, 0), new B(0, 0), new B(6, 6), new B(0, 0), new B(0, 0)
    };

    private readonly string[] _items = new string[] {
        "aaa", "aaaaa", "aaaaaaaaa", "aaaaaaaa", "aaaaaaaaaa", "aaaaaaa", "aaaaaa"
    };

    private readonly uint[] _hashCodes = {
        3645924380, 3844005527, 1495121428, 1489999822, 3989733254, 3612615712, 2517435613
    };

    
    public bool Contains(string value)
    {
       if ((1012UL & (1UL << (value.Length - 1) % 64)) == 0)
           return false;

        uint hash = Hash(value);
        ref B b = ref _buckets[MathHelper.FastMod(hash, 17, 1085102592571150096)];

        byte index = b.StartIndex;
        byte endIndex = b.EndIndex;

        while (index <= endIndex)
        {
            if (_hashCodes[index] == hash && StringComparer.Ordinal.Equals(value, _items[index]))
                return true;

            index++;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Hash(string value)
    {
        uint hash1 = (5381 << 16) + 5381;
        uint hash2 = (5381 << 16) + 5381;
        int length = value.Length;
        ReadOnlySpan<char> span = value.AsSpan();
        ref char ptr = ref MemoryMarshal.GetReference(span);
        ref uint ptr32 = ref Unsafe.As<char, uint>(ref ptr);

        while (length >= 4)
        {
            hash1 = (((hash1 << 5) | (hash1 >> (32 - 5))) + hash1) ^ ptr32;
            hash2 = (((hash2 << 5) | (hash2 >> (32 - 5))) + hash2) ^ Unsafe.Add(ref ptr32, 1);

            ptr32 = ref Unsafe.Add(ref ptr32, 2);
            length -= 4;
        }

        ref char ptrChar = ref Unsafe.As<uint, char>(ref ptr32);
        while (length-- > 0)
        {
            hash2 = (((hash2 << 5) | (hash2 >> (32 - 5))) + hash2) ^ ptrChar;
            ptrChar = ref Unsafe.Add(ref ptrChar, 1);
        }

        return hash1 + (hash2 * 1566083941);
    }

    [StructLayout(LayoutKind.Auto)]
    private struct B
    {
        internal B(byte startIndex, byte endIndex)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
        }

        internal byte StartIndex;
        internal byte EndIndex;
    }

    public const int ItemCount = 7;
    public int Length => ItemCount;
    public const int MinLength = 3;
    public const int MaxLength = 10;
}