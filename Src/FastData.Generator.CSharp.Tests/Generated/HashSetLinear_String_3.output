// <auto-generated />
// Structure: HashSetLinear
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Genbox.FastData.Helpers;


internal static class MyData 
{
    private static readonly B[] _buckets = {
        new B(0, 0), new B(0, 0), new B(1, 1), new B(0, 0), new B(2, 2), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), 
        new B(0, 0)
    };

    private static readonly string[] _items = new string[] {
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "item", "a"
    };

    private static readonly uint[] _hashCodes = {
        2265191819, 1949155672, 972181027
    };

    
    public static bool Contains(string value)
    {
        if (value.Length < 1u || value.Length > 255u)
            return false;

        uint hash = Hash(value);
        ref B b = ref _buckets[MathHelper.FastMod(hash, 11, 1676976733973595602)];

        byte index = b.StartIndex;
        byte endIndex = b.EndIndex;

        while (index <= endIndex)
        {
            if (_hashCodes[index] == hash && StringComparer.Ordinal.Equals(value, _items[index]))
                return true;

            index++;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Hash(string value)
    {
        uint hash1 = (5381 << 16) + 5381;
        uint hash2 = (5381 << 16) + 5381;
        int length = value.Length;
        ReadOnlySpan<char> span = value.AsSpan();
        ref char ptr = ref MemoryMarshal.GetReference(span);
        ref uint ptr32 = ref Unsafe.As<char, uint>(ref ptr);

        while (length >= 4)
        {
            hash1 = (((hash1 << 5) | (hash1 >> (32 - 5))) + hash1) ^ ptr32;
            hash2 = (((hash2 << 5) | (hash2 >> (32 - 5))) + hash2) ^ Unsafe.Add(ref ptr32, 1);

            ptr32 = ref Unsafe.Add(ref ptr32, 2);
            length -= 4;
        }

        ref char ptrChar = ref Unsafe.As<uint, char>(ref ptr32);
        while (length-- > 0)
        {
            hash2 = (((hash2 << 5) | (hash2 >> (32 - 5))) + hash2) ^ ptrChar;
            ptrChar = ref Unsafe.Add(ref ptrChar, 1);
        }

        return hash1 + (hash2 * 1566083941);
    }

    [StructLayout(LayoutKind.Auto)]
    private struct B
    {
        internal B(byte startIndex, byte endIndex)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
        }

        internal byte StartIndex;
        internal byte EndIndex;
    }

    public const int ItemCount = 3;
    public const int MinLength = 1;
    public const int MaxLength = 255;
}