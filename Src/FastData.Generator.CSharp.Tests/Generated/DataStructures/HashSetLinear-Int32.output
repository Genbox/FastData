// <auto-generated />
#nullable enable
using Genbox.FastData.Abstracts;
using Genbox.FastData.Generator.CSharp.Abstracts;
using Genbox.FastData.Helpers;
using Genbox.FastData;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System;


internal partial class MyData  : IFastSet<Int32>
{
    private readonly Bucket[] _buckets = {
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(1, 1),
        new Bucket(2, 2),
        new Bucket(3, 3),
        new Bucket(4, 4),
        new Bucket(5, 5),
        new Bucket(6, 6),
        new Bucket(7, 7),
        new Bucket(8, 8),
        new Bucket(9, 9),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0),
        new Bucket(0, 0)
    };

    private readonly int[] _items = {
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10
    };

    private readonly uint[] _hashCodes = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    
    public bool Contains(int value)
    {
        if (value < 1 || value > 10)
           return false;

        uint hashCode = Hash(value);
        ref Bucket b = ref _buckets[MathHelper.FastMod(hashCode, 23, 802032351030850071)];

        byte index = b.StartIndex;
        byte endIndex = b.EndIndex;

        while (index <= endIndex)
        {
            if (hashCode == _hashCodes[index] && value.Equals(_items[index]))
                return true;

            index++;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Hash(Int32 value) => unchecked((uint)value);

    [StructLayout(LayoutKind.Auto)]
    private struct Bucket
    {
        internal Bucket(byte startIndex, byte endIndex)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
        }

        internal byte StartIndex;
        internal byte EndIndex;
    }

    public const int ItemCount = 10;
    public int Length => 10;
}