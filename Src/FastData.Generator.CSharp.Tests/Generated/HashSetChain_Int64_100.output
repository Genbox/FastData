// <auto-generated />
// Structure: HashSetChain
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Genbox.FastData.Helpers;
using Genbox.FastData.Generator.CSharp.Abstracts;


internal partial class HashSetChain_Int64_100 : IFastSet<Int64>
{
    private readonly sbyte[] _buckets = new sbyte[] {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
        21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
        31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 
        51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 
        61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 
        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 
        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 
        91, 92, 93, 94, 95, 96, 97, 98, 99, 100
     };

    private readonly E[] _entries = {
        new E(0, -1, 0), new E(1, -1, 1), new E(2, -1, 2), new E(3, -1, 3), new E(4, -1, 4), new E(5, -1, 5), new E(6, -1, 6), new E(7, -1, 7), new E(8, -1, 8), new E(9, -1, 9), 
        new E(10, -1, 10), new E(11, -1, 11), new E(12, -1, 12), new E(13, -1, 13), new E(14, -1, 14), new E(15, -1, 15), new E(16, -1, 16), new E(17, -1, 17), new E(18, -1, 18), new E(19, -1, 19), 
        new E(20, -1, 20), new E(21, -1, 21), new E(22, -1, 22), new E(23, -1, 23), new E(24, -1, 24), new E(25, -1, 25), new E(26, -1, 26), new E(27, -1, 27), new E(28, -1, 28), new E(29, -1, 29), 
        new E(30, -1, 30), new E(31, -1, 31), new E(32, -1, 32), new E(33, -1, 33), new E(34, -1, 34), new E(35, -1, 35), new E(36, -1, 36), new E(37, -1, 37), new E(38, -1, 38), new E(39, -1, 39), 
        new E(40, -1, 40), new E(41, -1, 41), new E(42, -1, 42), new E(43, -1, 43), new E(44, -1, 44), new E(45, -1, 45), new E(46, -1, 46), new E(47, -1, 47), new E(48, -1, 48), new E(49, -1, 49), 
        new E(50, -1, 50), new E(51, -1, 51), new E(52, -1, 52), new E(53, -1, 53), new E(54, -1, 54), new E(55, -1, 55), new E(56, -1, 56), new E(57, -1, 57), new E(58, -1, 58), new E(59, -1, 59), 
        new E(60, -1, 60), new E(61, -1, 61), new E(62, -1, 62), new E(63, -1, 63), new E(64, -1, 64), new E(65, -1, 65), new E(66, -1, 66), new E(67, -1, 67), new E(68, -1, 68), new E(69, -1, 69), 
        new E(70, -1, 70), new E(71, -1, 71), new E(72, -1, 72), new E(73, -1, 73), new E(74, -1, 74), new E(75, -1, 75), new E(76, -1, 76), new E(77, -1, 77), new E(78, -1, 78), new E(79, -1, 79), 
        new E(80, -1, 80), new E(81, -1, 81), new E(82, -1, 82), new E(83, -1, 83), new E(84, -1, 84), new E(85, -1, 85), new E(86, -1, 86), new E(87, -1, 87), new E(88, -1, 88), new E(89, -1, 89), 
        new E(90, -1, 90), new E(91, -1, 91), new E(92, -1, 92), new E(93, -1, 93), new E(94, -1, 94), new E(95, -1, 95), new E(96, -1, 96), new E(97, -1, 97), new E(98, -1, 98), new E(99, -1, 99)
    };

    
    public bool Contains(long value)
    {
        if (value < 0 || value > 99)
           return false;

        uint hash = Hash(value);
        uint index = MathHelper.FastMod(hash, 100, 184467440737095517);
        sbyte i = (sbyte)(_buckets[index] - 1);

        while (i >= 0)
        {
            ref E entry = ref _entries[i];

            if (entry.HashCode == hash && value.Equals(entry.Value))
                return true;

            i = entry.Next;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Hash(long value) => unchecked((uint)(value.GetHashCode()));

    [StructLayout(LayoutKind.Auto)]
    private struct E
    {
        internal uint HashCode;
        internal sbyte Next;
        internal long Value;

        internal E(uint hashCode, sbyte next, long value)
        {
            HashCode = hashCode;
            Next = next;
            Value = value;
        }
    }

    public const int ItemCount = 100;
    public int Length => ItemCount;
    public const int MinValue = 0;
    public const int MaxValue = 99;
}