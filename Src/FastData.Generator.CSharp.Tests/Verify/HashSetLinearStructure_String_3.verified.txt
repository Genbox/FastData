// <auto-generated />
// This file is auto-generated. Do not edit manually.
// Structure: HashSet (HashSetLinear)
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class HashSetLinearStructure_String_3
{
    private static readonly B[] _buckets = {
        new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(1, 1), new B(2, 2), 
        new B(0, 0)
    };

    private static readonly string[] _items = new string[] {
        "item", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "a"
    };

    private static readonly ulong[] _hashCodes = {
        16750939634977259983, 9198652691199425319, 18225461187723808291
    };

    
    public static bool Contains(string value)
    {
        if (value.Length < 1u || value.Length > 255u)
            return false;

        ulong hash = Hash(value);
        ref B b = ref _buckets[(uint)(hash % 11)];

        byte index = b.StartIndex;
        byte endIndex = b.EndIndex;

        while (index <= endIndex)
        {
            if (StringComparer.Ordinal.Equals(_hashCodes[index], hash) && StringComparer.Ordinal.Equals(value, _items[index]))
                return true;

            index++;
        }

        return false;
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ulong Hash(string value)
    {
        ulong hash = 352654597;

        ref char ptr = ref MemoryMarshal.GetReference(value.AsSpan());
        int len = value.Length;

        while (len-- > 0)
        {
            hash = (((hash << 5) | (hash >> 27)) + hash) ^ ptr;
            ptr = ref Unsafe.Add(ref ptr, 1);
        }

        return 352654597 + (hash * 1566083941);
    }

    [StructLayout(LayoutKind.Auto)]
    private readonly struct B
    {
        internal readonly byte StartIndex;
        internal readonly byte EndIndex;

        internal B(byte startIndex, byte endIndex)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
        }
    }

    public const uint ItemCount = 3;
    public const uint MinLength = 1;
    public const uint MaxLength = 255;
}