<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>
<#@ import namespace="System" #>
<#@ import namespace="Genbox.FastData.Generator.Extensions" #>

<#@ parameter type="Genbox.FastData.Generator.CPlusPlus.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.RrrBitVectorContext" name="Context" #>

<#
    string mapSource = Model.KeyTypeCode switch
    {
        TypeCode.Char or TypeCode.Byte or TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64 => $"static_cast<uint64_t>({Common.LookupKeyName})",
        TypeCode.SByte => $"static_cast<uint64_t>(static_cast<uint8_t>({Common.LookupKeyName} ^ std::numeric_limits<int8_t>::lowest()))",
        TypeCode.Int16 => $"static_cast<uint64_t>(static_cast<uint16_t>({Common.LookupKeyName} ^ std::numeric_limits<int16_t>::lowest()))",
        TypeCode.Int32 => $"static_cast<uint64_t>(static_cast<uint32_t>({Common.LookupKeyName} ^ std::numeric_limits<int32_t>::lowest()))",
        TypeCode.Int64 => $"static_cast<uint64_t>({Common.LookupKeyName} ^ std::numeric_limits<int64_t>::lowest())",
        _ => throw new InvalidOperationException("RRR bitvector only supports integral key types.")
    };
#>
static constexpr uint64_t rrr_min_value = <#= Model.ToValueLabel(Context.MinValue) #>;
static constexpr uint64_t rrr_max_value = <#= Model.ToValueLabel(Context.MaxValue) #>;
static constexpr int32_t rrr_block_size = <#= Context.BlockSize #>;
<#= Model.GetFieldModifier(true) #>std::array<uint8_t, <#= Context.Classes.Length.ToStringInvariant() #>> rrr_classes = {
<#= FormatHelper.FormatColumns(Context.Classes, x => Model.ToValueLabel(x)) #>
};
<#= Model.GetFieldModifier(true) #>std::array<uint32_t, <#= Context.Offsets.Length.ToStringInvariant() #>> rrr_offsets = {
<#= FormatHelper.FormatColumns(Context.Offsets, x => Model.ToValueLabel(x)) #>
};

static constexpr int32_t binomial(int32_t n, int32_t k) noexcept {
    if (k < 0 || k > n)
        return 0;

    if (k == 0 || k == n)
        return 1;

    if (k > n - k)
        k = n - k;

    int32_t result = 1;

    for (int32_t i = 1; i <= k; i++)
        result = result * (n - (k - i)) / i;

    return result;
}

static constexpr bool decode_bit(int32_t class_value, uint32_t rank, int32_t target_bit) noexcept {
    int32_t remaining = class_value;

    for (int32_t bit = rrr_block_size - 1; bit >= 0; bit--) {
        if (remaining == 0)
            return false;

        const int32_t comb = binomial(bit, remaining);
        bool is_set = false;

        if (rank >= static_cast<uint32_t>(comb)) {
            rank -= static_cast<uint32_t>(comb);
            remaining--;
            is_set = true;
        }
        else
            is_set = false;

        if (bit == target_bit)
            return is_set;
    }

    return false;
}

public:
    <#= Model.MethodAttribute #>
    <#= Model.GetMethodModifier(true) #>bool contains(const <#= Model.KeyTypeName #> <#= Common.InputKeyName #>)<#= Model.PostMethodModifier #> {
<#= Model.GetMethodHeader(MethodType.Contains) #>

        const uint64_t mapped = <#= mapSource #>;

        if (mapped < rrr_min_value || mapped > rrr_max_value)
            return false;

        const uint64_t normalized = mapped - rrr_min_value;
        const int32_t block_index = static_cast<int32_t>(normalized / static_cast<uint64_t>(rrr_block_size));
        const int32_t bit_in_block = static_cast<int32_t>(normalized % static_cast<uint64_t>(rrr_block_size));
        const int32_t class_value = rrr_classes[static_cast<size_t>(block_index)];

        if (class_value == 0)
            return false;

        const uint32_t rank = rrr_offsets[static_cast<size_t>(block_index)];
        return decode_bit(class_value, rank, bit_in_block);
    }
