<#@ template language="C#" #>
<#@ import namespace="Genbox.FastData.Generator.Enums" #>
<#@ import namespace="Genbox.FastData.Generator.Helpers" #>
<#@ import namespace="Genbox.FastData.Generator.Extensions" #>

<#@ parameter type="Genbox.FastData.Generator.CPlusPlus.TemplateModel" name="Model" #>
<#@ parameter type="Genbox.FastData.Generator.Template.CommonDataModel" name="Common" #>
<#@ parameter type="Genbox.FastData.Generators.Contexts.EliasFanoContext" name="Context" #>

static constexpr int32_t lower_bit_count = <#= Context.LowerBitCount #>;
<#
    long minValue = Context.MinValue;
    long maxValue = Context.MaxValue;
    long maxValueNormalized = Context.MaxValue - Context.MinValue;
#>
static constexpr int64_t min_value = <#= Model.ToValueLabel(minValue) #>;
static constexpr int64_t max_value = <#= Model.ToValueLabel(maxValue) #>;
static constexpr int64_t max_value_normalized = <#= Model.ToValueLabel(maxValueNormalized) #>;
<#= Model.GetFieldModifier(true) #>std::array<uint64_t, <#= Context.UpperBits.Length.ToStringInvariant() #>> upper_bits = {
<#= FormatHelper.FormatColumns(Context.UpperBits, x => Model.ToValueLabel(x)) #>
};
<#
    if (Context.LowerBitCount != 0)
    {
#>

<#= Model.GetFieldModifier(true) #>std::array<uint64_t, <#= Context.LowerBits.Length.ToStringInvariant() #>> lower_bits = {
<#= FormatHelper.FormatColumns(Context.LowerBits, x => Model.ToValueLabel(x)) #>
};

static constexpr uint64_t lower_mask = <#= Model.ToValueLabel(Context.LowerMask) #>;
<#
    }
#>

static constexpr int32_t sample_rate_shift = <#= Context.SampleRateShift #>;
<#= Model.GetFieldModifier(true) #>std::array<int32_t, <#= Context.SamplePositions.Length.ToStringInvariant() #>> sample_positions = {
<#= FormatHelper.FormatColumns(Context.SamplePositions, x => Model.ToValueLabel(x)) #>
};

static constexpr int popcount(uint64_t value) noexcept {
    int count = 0;
    while (value != 0) {
        count += static_cast<int>(value & 1ULL);
        value >>= 1;
    }
    return count;
}

static constexpr int trailing_zero_count(uint64_t value) noexcept {
    if (value == 0) {
        return 64;
    }

    int count = 0;
    while ((value & 1ULL) == 0) {
        value >>= 1;
        count++;
    }
    return count;
}

static constexpr int select_bit_in_word(uint64_t word, int rank) noexcept {
    if (static_cast<uint32_t>(rank) >= 64u)
        return -1;

    int remaining = rank;
    uint64_t value = word;

    while (remaining > 0) {
        if (value == 0)
            return -1;

        value &= value - 1;
        remaining--;
    }

    if (value == 0)
        return -1;

    return trailing_zero_count(value);
}

static constexpr int64_t select_zero(int64_t rank) noexcept {
    if (rank < 0)
        return -1;

    const size_t sample_index = static_cast<size_t>(rank >> sample_rate_shift);
    if (sample_index >= sample_positions.size())
        return -1;

    int64_t zero_rank = static_cast<int64_t>(sample_index) << sample_rate_shift;
    int64_t start_position = sample_positions[sample_index];
    size_t word_index = static_cast<size_t>(start_position >> 6);
    int start_bit = static_cast<int>(start_position & 63);

    for (; word_index < upper_bits.size(); word_index++) {
        const int valid_bits = word_index == upper_bits.size() - 1 ? <#= (Context.UpperBitLength & 63) #> : 64;
        const uint64_t valid_mask = valid_bits == 64 ? std::numeric_limits<uint64_t>::max() : ((1ULL << valid_bits) - 1);
        uint64_t zeros = ~upper_bits[word_index] & valid_mask;

        if (start_bit > 0) {
            zeros &= ~((1ULL << start_bit) - 1);
            start_bit = 0;
        }

        const int zero_count = popcount(zeros);
        if (zero_count == 0)
            continue;

        if (zero_rank + zero_count > rank) {
            const int rank_in_word = static_cast<int>(rank - zero_rank);
            const int bit_in_word = select_bit_in_word(zeros, rank_in_word);
            return (static_cast<int64_t>(word_index) << 6) + bit_in_word;
        }

        zero_rank += zero_count;
    }

    return -1;
}

public:
<#= Model.MethodAttribute #>
<#= Model.GetMethodModifier(true) #>bool contains(const <#= Model.KeyTypeName #> <#= Common.InputKeyName #>)<#= Model.PostMethodModifier #> {
<#= Model.GetMethodHeader(MethodType.Contains) #>

<#
    if (minValue >= 0)
    {
#>    const int64_t value = static_cast<int64_t>(<#= Common.LookupKeyName #>);
    if (static_cast<uint64_t>(value) > static_cast<uint64_t>(max_value))
        return false;
<#
    }
    else
    {
#>    const int64_t value = static_cast<int64_t>(<#= Common.LookupKeyName #>) - min_value;
    if (static_cast<uint64_t>(value) > static_cast<uint64_t>(max_value_normalized))
        return false;
<#
    }
#>
    const int64_t high = value >> lower_bit_count;

    int64_t position = high == 0 ? 0 : select_zero(high - 1) + 1;
    if (position < 0)
        return false;

    int64_t rank = position - high;
    if (static_cast<uint64_t>(rank) >= item_count)
        return false;

    size_t curr_word = static_cast<size_t>(position >> 6);

    if (curr_word >= upper_bits.size())
        return false;

    uint64_t window = upper_bits[curr_word] & (std::numeric_limits<uint64_t>::max() << static_cast<uint32_t>(position & 63));
<#
    if (Context.LowerBitCount != 0)
    {
#>    const uint64_t target_low = static_cast<uint64_t>(value) & lower_mask;
    int64_t lower_bits_offset = rank * lower_bit_count;

    while (true) {
        while (window == 0) {
            curr_word++;
            if (curr_word >= upper_bits.size())
                return false;

            window = upper_bits[curr_word];
        }

        const int trailing = trailing_zero_count(window);
        const int64_t one_position = (static_cast<int64_t>(curr_word) << 6) + trailing;
        const int64_t current_high = one_position - rank;

        if (current_high >= high) {
            if (current_high > high)
                return false;

            const size_t word_index = static_cast<size_t>(lower_bits_offset >> 6);
            const int start_bit = static_cast<int>(lower_bits_offset & 63);

            uint64_t current_low = 0;
            if (start_bit + lower_bit_count <= 64)
                current_low = (lower_bits[word_index] >> start_bit) & lower_mask;
            else {
                const uint64_t lower = lower_bits[word_index] >> start_bit;
                const uint64_t upper = lower_bits[word_index + 1] << (64 - start_bit);
                current_low = (lower | upper) & lower_mask;
            }

            if (current_low == target_low)
                return true;

            if (current_low > target_low)
                return false;
        }

        window &= window - 1;
        rank++;

        if (static_cast<uint64_t>(rank) >= item_count)
            return false;

        lower_bits_offset += lower_bit_count;
    }
<#
    }
    else
    {
#>    while (true) {
        while (window == 0) {
            curr_word++;
            if (curr_word >= upper_bits.size())
                return false;

            window = upper_bits[curr_word];
        }

        const int trailing = trailing_zero_count(window);
        const int64_t one_position = (static_cast<int64_t>(curr_word) << 6) + trailing;
        const int64_t current_high = one_position - rank;

        if (current_high >= high) {
            if (current_high > high)
                return false;

            return true;
        }

        window &= window - 1;
        rank++;

        if (static_cast<uint64_t>(rank) >= item_count)
            return false;
    }
<#
    }
#>}
