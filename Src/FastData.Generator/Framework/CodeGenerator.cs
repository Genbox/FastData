using System.Text;
using Genbox.FastData.Enums;
using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.Enums;
using Genbox.FastData.Generator.Extensions;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generators;
using Genbox.FastData.Generators.Abstracts;
using Genbox.FastData.Generators.Extensions;

namespace Genbox.FastData.Generator.Framework;

public abstract class CodeGenerator(ILanguageDef langDef, IConstantsDef constDef, IEarlyExitDef earlyExitDef, IHashDef hashDef, TypeMap map, ExpressionCompiler? compiler) : ICodeGenerator
{
    protected SharedCode Shared { get; } = new SharedCode();

    public abstract GeneratorEncoding Encoding { get; }

    public virtual string Generate<TKey, TValue>(GeneratorConfigBase genCfg, IContext context)
    {
        Shared.Clear();

        string keyTypeName = map.GetTypeName(typeof(TKey));

        Type valueType = typeof(TValue);
        string valueTypeName = Type.GetTypeCode(valueType) == TypeCode.Object ? typeof(TValue).Name : map.GetTypeName(valueType);

        StringBuilder header = new StringBuilder();
        AppendHeader<TKey, TValue>(header, genCfg, context);

        StringBuilder body = new StringBuilder();
        AppendBody<TKey, TValue>(body, genCfg, keyTypeName, valueTypeName, context);

        StringBuilder footer = new StringBuilder();
        AppendFooter<TKey>(footer, genCfg, keyTypeName);

        foreach (string code in Shared.GetType(CodePlacement.After))
            footer.AppendLine(code);

        StringBuilder final = new StringBuilder();
        final.Append(header);

        foreach (string code in Shared.GetType(CodePlacement.Before))
            final.AppendLine(code);

        final.Append(body);
        final.Append(footer);
        return final.ToString();
    }

    protected abstract OutputWriter<TKey>? GetOutputWriter<TKey, TValue>(GeneratorConfigBase genCfg, IContext context);

    protected virtual void AppendHeader<TKey, TValue>(StringBuilder sb, GeneratorConfigBase genCfg, IContext context)
    {
        sb.Append(constDef.Comment).Append(' ').AppendLine("This file is auto-generated. Do not edit manually.");
        sb.Append(constDef.Comment).Append(' ').AppendLine($"Structure: {genCfg.StructureType.GetCleanName().Replace("Structure", "")}");

#if RELEASE
        sb.Append(constDef.Comment).Append(' ').AppendLine("Generated by: " + genCfg.Metadata.Program);
        sb.Append(constDef.Comment).Append(' ').AppendLine("Generated on: " + genCfg.Metadata.Timestamp);
#endif
    }

    protected virtual void AppendBody<TKey, TValue>(StringBuilder sb, GeneratorConfigBase genCfg, string keyTypeName, string valueTypeName, IContext context)
    {
        OutputWriter<TKey>? writer = GetOutputWriter<TKey, TValue>(genCfg, context);

        if (writer == null)
            throw new NotSupportedException("The context type is not supported: " + context.GetType().Name);

        writer.Initialize(langDef, earlyExitDef, map, hashDef, genCfg, keyTypeName, valueTypeName, compiler, Shared);

        foreach (string code in Shared.GetType(CodePlacement.InClass))
            sb.AppendLine(code);

        string str = writer.Generate();

        int start = 0;
        int end = str.Length;

        while (start < end)
        {
            char c = str[start];
            if (c != '\r' && c != '\n')
                break;

            start++;
        }

        while (end > start)
        {
            char c = str[end - 1];
            if (c != '\r' && c != '\n')
                break;

            end--;
        }

        bool atLineStart = true;

        for (int i = start; i < end; i++)
        {
            char c = str[i];

            if (atLineStart)
            {
                if (c == '\r' || c == '\n')
                {
                    if (c == '\r' && i + 1 < str.Length && str[i + 1] == '\n')
                    {
                        sb.Append('\r');
                        sb.Append('\n');
                        i++;
                    }
                    else
                    {
                        sb.Append(c);
                    }

                    continue;
                }

                sb.Append("    ");
                atLineStart = false;
            }

            if (c == '\r' || c == '\n')
            {
                if (c == '\r' && i + 1 < str.Length && str[i + 1] == '\n')
                {
                    sb.Append('\r');
                    sb.Append('\n');
                    i++;
                }
                else
                {
                    sb.Append(c);
                }

                atLineStart = true;
                continue;
            }

            sb.Append(c);
        }
    }

    protected virtual void AppendFooter<T>(StringBuilder sb, GeneratorConfigBase genCfg, string typeName)
    {
        sb.AppendLine();
        sb.AppendLine();
        sb.AppendLine(constDef.ItemCountTemplate(langDef.ArraySizeType, genCfg.ItemCount.ToStringInvariant()));

        if (genCfg is NumericGeneratorConfig<T> numericCfg)
        {
            sb.AppendLine(constDef.MinValueTemplate(typeName, map.ToValueLabel(numericCfg.Constants.MinValue)));
            sb.AppendLine(constDef.MaxValueTemplate(typeName, map.ToValueLabel(numericCfg.Constants.MaxValue)));
        }
        else if (genCfg is StringGeneratorConfig stringCfg)
        {
            sb.AppendLine(constDef.MinLengthTemplate(langDef.ArraySizeType, stringCfg.Constants.MinStringLength.ToStringInvariant()));
            sb.AppendLine(constDef.MaxLengthTemplate(langDef.ArraySizeType, stringCfg.Constants.MaxStringLength.ToStringInvariant()));
            sb.AppendLine(constDef.CharacterClassesTemplate(stringCfg.Constants.CharacterClasses));
        }
    }
}