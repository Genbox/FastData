using System.Text;
using Genbox.FastData.Enums;
using Genbox.FastData.Generator.Enums;
using Genbox.FastData.Generator.Extensions;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generators;
using Genbox.FastData.Generators.Abstracts;
using Genbox.FastData.Generators.Extensions;

namespace Genbox.FastData.Generator.Framework;

public abstract class CodeGenerator(ILanguageDef langDef, IConstantsDef constDef, IEarlyExitDef earlyExitDef, IHashDef hashDef, TypeMap map, ExpressionCompiler? compiler) : ICodeGenerator
{
    protected SharedCode Shared { get; } = new SharedCode();

    public GeneratorEncoding Encoding => langDef.Encoding;

    public virtual string Generate<TKey, TValue>(GeneratorConfig<TKey> genCfg, IContext<TValue> context)
    {
        Shared.Clear();

        // If we can reduce the encoding to ASCII, we do so
        map.OverrideEncoding(genCfg.Flags.HasFlag(GeneratorFlags.AllAreASCII) ? GeneratorEncoding.ASCII : Encoding);

        string keyTypeName = map.GetTypeName(typeof(TKey));

        Type valueType = typeof(TValue);
        string valueTypeName = Type.GetTypeCode(valueType) == TypeCode.Object ? typeof(TValue).Name : map.GetTypeName(valueType);

        StringBuilder header = new StringBuilder();
        AppendHeader(header, genCfg, context);

        StringBuilder body = new StringBuilder();
        AppendBody(body, genCfg, keyTypeName, valueTypeName, context);

        StringBuilder footer = new StringBuilder();
        AppendFooter(footer, genCfg, keyTypeName);

        foreach (string code in Shared.GetType(CodePlacement.After))
            footer.AppendLine(code);

        StringBuilder final = new StringBuilder();
        final.Append(header);

        foreach (string code in Shared.GetType(CodePlacement.Before))
            final.AppendLine(code);

        final.Append(body);
        final.Append(footer);
        return final.ToString();
    }

    protected abstract OutputWriter<TKey>? GetOutputWriter<TKey, TValue>(GeneratorConfig<TKey> genCfg, IContext<TValue> context);

    protected virtual void AppendHeader<TKey, TValue>(StringBuilder sb, GeneratorConfig<TKey> genCfg, IContext<TValue> context)
    {
        string subType = context.GetType().Name.Replace("Context`1", "").Replace("Context`2", "");

        sb.Append(constDef.Comment).Append(' ').AppendLine("This file is auto-generated. Do not edit manually.");
        sb.Append(constDef.Comment).Append(' ').AppendLine($"Structure: {genCfg.StructureType}{(genCfg.StructureType.ToString() != subType ? $" ({subType})" : string.Empty)}");

#if RELEASE
        sb.Append(constDef.Comment).Append(' ').AppendLine("Generated by: " + genCfg.Metadata.Program);
        sb.Append(constDef.Comment).Append(' ').AppendLine("Generated on: " + genCfg.Metadata.Timestamp);
#endif
    }

    protected virtual void AppendBody<TKey, TValue>(StringBuilder sb, GeneratorConfig<TKey> genCfg, string keyTypeName, string valueTypeName, IContext<TValue> context)
    {
        OutputWriter<TKey>? writer = GetOutputWriter(genCfg, context);

        if (writer == null)
            throw new NotSupportedException("The context type is not supported: " + context.GetType().Name);

        writer.Initialize(langDef, earlyExitDef, map, hashDef, genCfg, keyTypeName, valueTypeName, context.Values, compiler, Shared);

        foreach (string code in Shared.GetType(CodePlacement.InClass))
            sb.AppendLine(code);

        sb.AppendLine(writer.Generate());
    }

    protected virtual void AppendFooter<T>(StringBuilder sb, GeneratorConfig<T> genCfg, string typeName)
    {
        sb.AppendLine();
        sb.AppendLine(constDef.ItemCountTemplate(langDef.ArraySizeType, genCfg.Constants.ItemCount.ToStringInvariant()));

        if (genCfg.KeyType.IsInteger())
        {
            sb.AppendLine(constDef.MinValueTemplate(typeName, map.ToValueLabel(genCfg.Constants.MinValue)));
            sb.AppendLine(constDef.MaxValueTemplate(typeName, map.ToValueLabel(genCfg.Constants.MaxValue)));
        }
        else if (genCfg.KeyType == KeyType.String)
        {
            sb.AppendLine(constDef.MinLengthTemplate(langDef.ArraySizeType, genCfg.Constants.MinStringLength.ToStringInvariant()));
            sb.AppendLine(constDef.MaxLengthTemplate(langDef.ArraySizeType, genCfg.Constants.MaxStringLength.ToStringInvariant()));
            sb.AppendLine(constDef.CharacterClassesTemplate(genCfg.Constants.CharacterClasses));
        }
    }
}