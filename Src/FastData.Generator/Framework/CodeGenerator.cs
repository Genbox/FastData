using System.Text;
using Genbox.FastData.Abstracts;
using Genbox.FastData.Configs;
using Genbox.FastData.Enums;
using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.Enums;
using Genbox.FastData.Generator.Extensions;
using Genbox.FastData.Generator.Framework.Interfaces;

namespace Genbox.FastData.Generator.Framework;

public abstract class CodeGenerator : ICodeGenerator
{
    private readonly TypeMap _typeMap;
    private readonly ILanguageDef _langDef;
    private readonly IConstantsDef _constDef;
    private readonly IEarlyExitDef _earlyExitDef;
    private readonly IHashDef _hashDef;
    private readonly ExpressionCompiler _compiler;

    protected CodeGenerator(ILanguageDef langDef, IConstantsDef constDef, IEarlyExitDef earlyExitDef, IHashDef hashDef, ExpressionCompiler compiler)
    {
        _langDef = langDef;
        _constDef = constDef;
        _earlyExitDef = earlyExitDef;
        _hashDef = hashDef;
        _compiler = compiler;

        _typeMap = new TypeMap(langDef.TypeDefinitions);
        Typehelper = new TypeHelper(_typeMap);
        Shared = new SharedCode();
    }

    public bool UseUTF16Encoding => _langDef.UseUTF16Encoding;
    public SharedCode Shared { get; }
    public TypeHelper Typehelper { get; }

    public virtual bool TryGenerate<T>(GeneratorConfig<T> genCfg, IContext context, out string? source)
    {
        Shared.Clear();

        string typeName = _typeMap.Get<T>().Name;

        StringBuilder sb = new StringBuilder();
        AppendHeader(sb, genCfg);
        AppendBody(sb, genCfg, typeName, context, _compiler);
        AppendFooter(sb, genCfg, typeName);

        foreach (string classCode in Shared.GetType(CodeType.Class))
        {
            sb.AppendLine();
            sb.AppendLine(classCode);
        }

        source = sb.ToString();
        return true;
    }

    protected abstract OutputWriter<T>? GetOutputWriter<T>(GeneratorConfig<T> genCfg, IContext context);

    protected virtual void AppendHeader<T>(StringBuilder sb, GeneratorConfig<T> genCfg)
    {
        sb.Append(_constDef.Comment).Append(' ').AppendLine("This file is auto-generated. Do not edit manually.");
        sb.Append(_constDef.Comment).Append(' ').AppendLine("Structure: " + genCfg.StructureType);

#if RELEASE
        sb.Append(_constDef.Comment).Append(' ').AppendLine("Generated by: " + genCfg.Metadata.Program);
        sb.Append(_constDef.Comment).Append(' ').AppendLine("Generated on: " + genCfg.Metadata.Timestamp);
#endif
    }

    protected virtual void AppendBody<T>(StringBuilder sb, GeneratorConfig<T> genCfg, string typeName, IContext context, ExpressionCompiler? compiler)
    {
        OutputWriter<T>? writer = GetOutputWriter(genCfg, context);

        if (writer == null)
            throw new NotSupportedException("The context type is not supported: " + context.GetType().Name);

        writer.Initialize(_langDef, _earlyExitDef, Typehelper, _hashDef, genCfg, typeName, compiler);
        sb.AppendLine(writer.Generate());
    }

    protected virtual void AppendFooter<T>(StringBuilder sb, GeneratorConfig<T> genCfg, string typeName)
    {
        sb.AppendLine();
        sb.AppendLine(_constDef.ItemCountTemplate(_langDef.ArraySizeType, genCfg.Constants.ItemCount.ToStringInvariant()));

        if (genCfg.DataType.IsInteger())
        {
            sb.AppendLine(_constDef.MinValueTemplate(typeName, Typehelper.ToValueLabel(genCfg.Constants.MinValue)));
            sb.AppendLine(_constDef.MaxValueTemplate(typeName, Typehelper.ToValueLabel(genCfg.Constants.MaxValue)));
        }
        else if (genCfg.DataType == DataType.String)
        {
            sb.AppendLine(_constDef.MinLengthTemplate(_langDef.ArraySizeType, genCfg.Constants.MinStringLength.ToStringInvariant()));
            sb.AppendLine(_constDef.MaxLengthTemplate(_langDef.ArraySizeType, genCfg.Constants.MaxStringLength.ToStringInvariant()));
        }
    }
}