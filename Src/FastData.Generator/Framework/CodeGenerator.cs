using System.Text;
using Genbox.FastData.Abstracts;
using Genbox.FastData.Configs;
using Genbox.FastData.Enums;
using Genbox.FastData.Extensions;
using Genbox.FastData.Generator.Framework.Interfaces;
using Genbox.FastData.Generator.Framework.Interfaces.Specs;

namespace Genbox.FastData.Generator.Framework;

public abstract class CodeGenerator : ICodeGenerator
{
    private readonly TypeMap _typeMap;
    private readonly CodeHelper _helper;
    private readonly ICodeSpec _codeSpec;
    private readonly IConstantsSpec _constants;
    private readonly IEarlyExitHandler _earlyExitHandler;
    private readonly IHashHandler _hashHandler;

    private readonly string _arrayType;

    protected CodeGenerator(ILanguageSpec langSpec, ICodeSpec codeSpec, IConstantsSpec constants, IEarlyExitHandler earlyExitHandler, IHashHandler hashHandler)
    {
        _codeSpec = codeSpec;
        _constants = constants;
        _earlyExitHandler = earlyExitHandler;
        _hashHandler = hashHandler;

        _typeMap = new TypeMap(langSpec.Primitives);
        _helper = new CodeHelper(langSpec, _typeMap);

        _arrayType = _typeMap.GetArraySizeType().Name;
    }

    public bool UseUTF16Encoding => false;

    public virtual bool TryGenerate<T>(GeneratorConfig genCfg, IContext context, out string? source)
    {
        string typeName = _typeMap.GetRequired<T>().Name;

        StringBuilder sb = new StringBuilder();
        AppendHeader(sb, genCfg);
        AppendBody<T>(sb, genCfg, typeName, context);
        AppendFooter(sb, genCfg, typeName);

        source = sb.ToString();
        return true;
    }

    protected abstract OutputWriter? GetOutputWriter<T>(GeneratorConfig genCfg, IContext context);

    protected virtual void AppendHeader(StringBuilder sb, GeneratorConfig genCfg)
    {
        _helper.Comment(sb, "This file is auto-generated. Do not edit manually.");
        _helper.Comment(sb, "Structure: " + genCfg.StructureType);

#if RELEASE
        _helper.Comment(sb, "Generated by: " + genCfg.Metadata.Program);
        _helper.Comment(sb, "Generated on: " + genCfg.Metadata.Timestamp);
#endif
    }

    protected virtual void AppendBody<T>(StringBuilder sb, GeneratorConfig genCfg, string typeName, IContext context)
    {
        OutputWriter? writer = GetOutputWriter<T>(genCfg, context);

        if (writer == null)
            throw new NotSupportedException("The context type is not supported: " + context.GetType().Name);

        writer.Initialize(_codeSpec, _typeMap, _earlyExitHandler, _helper, _hashHandler, genCfg, typeName);
        sb.Append(writer.Generate());
    }

    protected virtual void AppendFooter(StringBuilder sb, GeneratorConfig genCfg, string typeName)
    {
        sb.Append($"    {_codeSpec.GetFieldModifier()} {_arrayType} {_constants.ItemName} = {genCfg.Constants.ItemCount};");

        if (genCfg.DataType.IsInteger())
        {
            sb.Append($"    {_codeSpec.GetFieldModifier()} {typeName} {_constants.MinValueName} = {_helper.ToValueLabel(genCfg.Constants.MinValue, genCfg.DataType)};");
            sb.Append($"    {_codeSpec.GetFieldModifier()} {typeName} {_constants.MaxValueName} = {_helper.ToValueLabel(genCfg.Constants.MaxValue, genCfg.DataType)};");
        }
        else if (genCfg.DataType == DataType.String)
        {
            sb.Append($"    {_codeSpec.GetFieldModifier()} {_arrayType} {_constants.MinLengthName} = {genCfg.Constants.MinValue};");
            sb.Append($"    {_codeSpec.GetFieldModifier()} {_arrayType} {_constants.MaxLengthName} = {genCfg.Constants.MaxValue};");
        }
    }
}