// This file is auto-generated. Do not edit manually.
// Structure: HashTable
#pragma once
#include <array>
#include <cstdint>
#include <limits>
#include <string_view>

class HashTableStructure_Single_100 final {
    struct e {
        float key;
        int8_t next;
        uint64_t hash_code;
        
        e(const float key, const int8_t next, const uint64_t hash_code)
           : key(key), next(next), hash_code(hash_code) {}
    };

    static constexpr std::array<int8_t, 100> buckets = {
        78, 0, 0, 0, 85, 0, 0, 0, 92, 0, 
        0, 0, 99, 0, 0, 0, 81, 0, 0, 0, 
        88, 0, 0, 0, 95, 0, 0, 0, 77, 0, 
        0, 0, 84, 0, 0, 0, 91, 0, 0, 0, 
        98, 0, 0, 0, 80, 0, 0, 0, 87, 0, 
        0, 0, 94, 0, 0, 0, 76, 0, 0, 0, 
        83, 0, 0, 0, 90, 0, 0, 0, 97, 0, 
        0, 0, 79, 0, 0, 0, 86, 0, 0, 0, 
        93, 0, 0, 0, 100, 0, 0, 0, 82, 0, 
        0, 0, 89, 0, 0, 0, 96, 0, 0, 0
     };

    inline static const std::array<e, 100> entries = {
        e(0.0f, -1, 0), e(1.0f, -1, 1065353216), e(2.0f, -1, 1073741824), e(3.0f, -1, 1077936128), e(4.0f, -1, 1082130432), e(5.0f, -1, 1084227584), e(6.0f, -1, 1086324736), e(7.0f, -1, 1088421888), e(8.0f, -1, 1090519040), e(9.0f, 1, 1091567616), 
        e(10.0f, -1, 1092616192), e(11.0f, -1, 1093664768), e(12.0f, -1, 1094713344), e(13.0f, -1, 1095761920), e(14.0f, -1, 1096810496), e(15.0f, -1, 1097859072), e(16.0f, -1, 1098907648), e(17.0f, 6, 1099431936), e(18.0f, 2, 1099956224), e(19.0f, -1, 1100480512), 
        e(20.0f, 0, 1101004800), e(21.0f, 7, 1101529088), e(22.0f, -1, 1102053376), e(23.0f, -1, 1102577664), e(24.0f, -1, 1103101952), e(25.0f, 8, 1103626240), e(26.0f, 3, 1104150528), e(27.0f, 9, 1104674816), e(28.0f, -1, 1105199104), e(29.0f, 10, 1105723392), 
        e(30.0f, -1, 1106247680), e(31.0f, 11, 1106771968), e(32.0f, -1, 1107296256), e(33.0f, 20, 1107558400), e(34.0f, 12, 1107820544), e(35.0f, 21, 1108082688), e(36.0f, 4, 1108344832), e(37.0f, 22, 1108606976), e(38.0f, 13, 1108869120), e(39.0f, 23, 1109131264), 
        e(40.0f, -1, 1109393408), e(41.0f, 24, 1109655552), e(42.0f, 14, 1109917696), e(43.0f, 25, 1110179840), e(44.0f, 5, 1110441984), e(45.0f, 26, 1110704128), e(46.0f, 15, 1110966272), e(47.0f, 27, 1111228416), e(48.0f, -1, 1111490560), e(49.0f, 28, 1111752704), 
        e(50.0f, 16, 1112014848), e(51.0f, 29, 1112276992), e(52.0f, 17, 1112539136), e(53.0f, 30, 1112801280), e(54.0f, 18, 1113063424), e(55.0f, 31, 1113325568), e(56.0f, 19, 1113587712), e(57.0f, 32, 1113849856), e(58.0f, 33, 1114112000), e(59.0f, 34, 1114374144), 
        e(60.0f, 35, 1114636288), e(61.0f, 36, 1114898432), e(62.0f, 37, 1115160576), e(63.0f, 38, 1115422720), e(64.0f, 39, 1115684864), e(65.0f, 52, 1115815936), e(66.0f, 40, 1115947008), e(67.0f, 53, 1116078080), e(68.0f, 41, 1116209152), e(69.0f, 54, 1116340224), 
        e(70.0f, 42, 1116471296), e(71.0f, 55, 1116602368), e(72.0f, 43, 1116733440), e(73.0f, 56, 1116864512), e(74.0f, 44, 1116995584), e(75.0f, 57, 1117126656), e(76.0f, 45, 1117257728), e(77.0f, 58, 1117388800), e(78.0f, 46, 1117519872), e(79.0f, 59, 1117650944), 
        e(80.0f, 47, 1117782016), e(81.0f, 60, 1117913088), e(82.0f, 48, 1118044160), e(83.0f, 61, 1118175232), e(84.0f, 49, 1118306304), e(85.0f, 62, 1118437376), e(86.0f, 50, 1118568448), e(87.0f, 63, 1118699520), e(88.0f, 51, 1118830592), e(89.0f, 64, 1118961664), 
        e(90.0f, 65, 1119092736), e(91.0f, 66, 1119223808), e(92.0f, 67, 1119354880), e(93.0f, 68, 1119485952), e(94.0f, 69, 1119617024), e(95.0f, 70, 1119748096), e(96.0f, 71, 1119879168), e(97.0f, 72, 1120010240), e(98.0f, 73, 1120141312), e(99.0f, 74, 1120272384)
    };

    static uint64_t get_hash(const float value) noexcept
    {
        uint32_t bits;
        std::memcpy(&bits, &value, sizeof(bits));
        if (((bits - 1) & ~0x80000000u) >= 0x7F800000u)
            bits &= 0x7F800000u;
        return bits;
    }

public:
    [[nodiscard]]
    static constexpr bool contains(const float key) noexcept {
        if (key < 0.0f || key > 99.0f)
            return false;

        const uint64_t hash = get_hash(key);
        const size_t index = hash % 100;
        int8_t i = static_cast<int8_t>(buckets[index] - 1);

        while (i >= 0) {
            const auto& entry = entries[i];

            if (entry.hash_code == hash && entry.key == key)
                return true;

            i = entry.next;
        }

        return false;
    }

    static constexpr size_t item_count = 100;
    static constexpr float min_key = 0.0f;
    static constexpr float max_key = 99.0f;
};