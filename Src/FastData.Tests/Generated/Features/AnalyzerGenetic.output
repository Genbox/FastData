// <auto-generated />
#nullable enable
using Genbox.FastData;
using Genbox.FastData.Abstracts;
using Genbox.FastData.Helpers;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Text;
using System;


internal static class ImmutableSet 
{
    private static readonly int[] _buckets = { 8, 9, 2, 0, 6, 7, 10, 3, 4, 5 };

    private static readonly Entry[] _entries = {
        new Entry(2011983611, -1, "item1"),
        new Entry(3578067552, -1, "item2"),
        new Entry(849184197, -1, "item3"),
        new Entry(2415268138, -1, "item4"),
        new Entry(3981352079, -1, "item5"),
        new Entry(1252468724, -1, "item6"),
        new Entry(2818552665, -1, "item7"),
        new Entry(802130030, -1, "item8"),
        new Entry(2368213971, 0, "item9"),
        new Entry(1309368076, -1, "item10")
    };

    
    public static bool Contains(string value)
    {
        if (value.Length < 5 || value.Length > 6)
           return false;

        uint hashCode = Hash(value);
        uint index = MathHelper.FastMod(hashCode, 10, 1844674407370955162);
        int i = _buckets[index] - 1;

        while (i >= 0)
        {
            ref Entry entry = ref _entries[i];

            if (entry.HashCode == hashCode && entry.Value.Equals(value))
                return true;

            i = entry.Next;
        }

        return false;
    }

    public static uint Hash(string str)
    {
        ref byte ptr = ref Unsafe.As<char, byte>(ref MemoryMarshal.GetReference(str.AsSpan()));
        int length = str.Length * 2;
        ulong acc = 42;

        if (length >= 32)
        {
            ref byte limit = ref Unsafe.Add(ref ptr, length - 31);

            ulong acc0 = 0; //TODO: Seed correctly
            ulong acc1 = 0;
            ulong acc2 = 0;
            ulong acc3 = 0;

            do
            {
                acc0 = Mixer(acc0, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);

                acc1 = Mixer(acc1, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);

                acc2 = Mixer(acc2, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);

                acc3 = Mixer(acc3, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);
            } while (Unsafe.IsAddressLessThan(ref ptr, ref limit));

            acc = Mixer(acc, acc0);
            acc = Mixer(acc, acc1);
            acc = Mixer(acc, acc2);
            acc = Mixer(acc, acc3);

            //TODO: acc += length;
            length &= 31;
        }

        if (length >= 16)
        {
            ref byte limit = ref Unsafe.Add(ref ptr, length - 15);

            ulong acc0 = 0; //TODO: Seed correctly
            ulong acc1 = 0;

            do
            {
                acc0 = Mixer(acc0, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);

                acc1 = Mixer(acc1, Unsafe.ReadUnaligned<ulong>(ref ptr));
                ptr = ref Unsafe.Add(ref ptr, 8);
            } while (Unsafe.IsAddressLessThan(ref ptr, ref limit));

            acc = Mixer(acc, acc0);
            acc = Mixer(acc, acc1);

            //TODO: acc += length;
            length &= 15;
        }

        while (length >= 8)
        {
            acc = Mixer(acc, Unsafe.ReadUnaligned<ulong>(ref ptr));
            ptr = ref Unsafe.Add(ref ptr, 8);
            length -= 8;
        }

        if (length >= 4)
        {
            acc = Mixer(acc, Unsafe.ReadUnaligned<uint>(ref ptr));
            ptr = ref Unsafe.Add(ref ptr, 4);
            length -= 4;
        }

        while (length > 0)
        {
            acc = Mixer(acc, Unsafe.ReadUnaligned<byte>(ref ptr));
            ptr = ref Unsafe.Add(ref ptr, 1);
            length--;
        }

        var accParam = acc;
        acc = accParam;

        return (uint)acc;
    }

    public static ulong Mixer(ulong accParam, ulong inputParam)
    {
        ulong acc = (accParam + (inputParam * 2246822507));
acc = ((1 | acc) + (acc * acc));
acc = ((acc >> 5) | (acc << 59));
acc = ((acc << 1) | (acc >> 63));
acc = ((acc << 14) | (acc >> 50));

        return acc;
    }

    [StructLayout(LayoutKind.Auto)]
    private struct Entry
    {
        public uint HashCode;
        public short Next;
        public string Value;

        public Entry(uint hashCode, short next, string value)
        {
            HashCode = hashCode;
            Next = next;
            Value = value;
        }
    }

    public const int ItemCount = 10;
}
